/******************************************************************************
 * SOLINA ENSEMBLE
 * Classic 3-voice BBD string ensemble effect
 * Recreates the ARP Solina (1974) tri-phase chorus
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#include "ImagePanel.hpp"
#define FAUST_MODULE_NAME SolinaEnsemble
#include "solina_ensemble.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * SolinaEnsemble - Classic String Ensemble Effect
 *
 * Transforms thin waveforms into massive, swirling orchestral strings
 * using 3 BBD delay lines with 120° phase-shifted LFO modulation.
 *
 * Inputs:
 *   - L/R: Audio input (summed to mono internally)
 *
 * Parameters:
 *   - Depth: Modulation intensity
 *   - Rate: LFO speed scaling (1.0 = original Solina)
 *   - Tone: BBD lowpass filter frequency
 *   - Mix: Dry/wet blend
 */
struct SolinaEnsemble : FaustModule<VCVRackDSP> {
    enum ParamId {
        DEPTH_PARAM,
        RATE_PARAM,
        TONE_PARAM,
        MIX_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        LEFT_INPUT,
        RIGHT_INPUT,
        MIX_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    SolinaEnsemble() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Configure parameters
        configParam(DEPTH_PARAM, 0.0f, 2.0f, 1.0f, "Depth", "%", 0.f, 50.f);
        configParam(RATE_PARAM, 0.1f, 3.0f, 1.0f, "Rate", "x");
        configParam(TONE_PARAM, 500.0f, 20000.0f, 8000.0f, "Tone", " Hz");
        configParam(MIX_PARAM, 0.0f, 1.0f, 1.0f, "Mix", "%", 0.f, 100.f);

        // Configure inputs
        configInput(LEFT_INPUT, "Left");
        configInput(RIGHT_INPUT, "Right");
        configInput(MIX_CV_INPUT, "Mix CV");

        // Configure outputs
        configOutput(LEFT_OUTPUT, "Left");
        configOutput(RIGHT_OUTPUT, "Right");

        // Faust params (alphabetical): depth=0, mix=1, rate=2, tone=3
        mapParam(DEPTH_PARAM, 0);
        mapParam(MIX_PARAM, 1);
        mapParam(RATE_PARAM, 2);
        mapParam(TONE_PARAM, 3);
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Get parameters
        float depth = params[DEPTH_PARAM].getValue();
        float rate = params[RATE_PARAM].getValue();
        float tone = params[TONE_PARAM].getValue();

        // Get mix with CV modulation
        float mix = params[MIX_PARAM].getValue();
        if (inputs[MIX_CV_INPUT].isConnected()) {
            mix += inputs[MIX_CV_INPUT].getVoltage() * 0.1f;  // ±10V = ±1.0
        }
        mix = clamp(mix, 0.f, 1.f);

        // Update Faust parameters (alphabetical order)
        faustDsp.setParamValue(0, depth);  // depth
        faustDsp.setParamValue(1, mix);    // mix
        faustDsp.setParamValue(2, rate);   // rate
        faustDsp.setParamValue(3, tone);   // tone

        // Get audio input (sum to mono)
        float inL = inputs[LEFT_INPUT].getVoltage();
        float inR = inputs[RIGHT_INPUT].isConnected() ? inputs[RIGHT_INPUT].getVoltage() : inL;
        float monoIn = (inL + inR) * 0.5f;

        // Process audio
        float outputL = 0.0f, outputR = 0.0f;
        float* inputPtrs[1] = { &monoIn };
        float* outputPtrs[2] = { &outputL, &outputR };

        faustDsp.compute(1, inputPtrs, outputPtrs);

        // Output
        outputs[LEFT_OUTPUT].setVoltage(outputL);
        outputs[RIGHT_OUTPUT].setVoltage(outputR);
    }
};

struct SolinaEnsembleWidget : ModuleWidget {
    SolinaEnsembleWidget(SolinaEnsemble* module) {
        setModule(module);
        box.size = Vec(4 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);
        addChild(new WiggleRoom::ImagePanel(
            asset::plugin(pluginInstance, "res/SolinaEnsemble.png"), box.size));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        float xCenter = box.size.x / 2.0f;
        float xLeft = xCenter - 18;
        float xRight = xCenter + 18;

        // Main Depth knob at top
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(xCenter, 55), module, SolinaEnsemble::DEPTH_PARAM));

        // Rate and Tone knobs
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 110), module, SolinaEnsemble::RATE_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 110), module, SolinaEnsemble::TONE_PARAM));

        // Mix knob
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xCenter, 160), module, SolinaEnsemble::MIX_PARAM));

        // Mix CV input
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter, 200), module, SolinaEnsemble::MIX_CV_INPUT));

        // Audio inputs
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 265), module, SolinaEnsemble::LEFT_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 265), module, SolinaEnsemble::RIGHT_INPUT));

        // Stereo Outputs
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xLeft, 320), module, SolinaEnsemble::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xRight, 320), module, SolinaEnsemble::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelSolinaEnsemble = createModel<WiggleRoom::SolinaEnsemble, WiggleRoom::SolinaEnsembleWidget>("SolinaEnsemble");
