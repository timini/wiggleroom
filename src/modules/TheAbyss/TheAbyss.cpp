/******************************************************************************
 * THE ABYSS - Waterphone
 * Horror-movie instrument with bowed metal rods and water modulation
 * Bow -> Modal Rods -> Bowl Resonance
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#define FAUST_MODULE_NAME TheAbyss
#include "the_abyss.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * TheAbyss - Waterphone
 *
 * A physical model of the Waterphone, famous for horror movie soundtracks.
 *
 * Signal chain:
 *   1. Bow (Stick-slip friction) - creates the eerie singing tone
 *   2. Rods (Modal resonators) - dissonant metallic cluster
 *   3. Water (Chaotic LFOs) - pitch warping for underwater effect
 *   4. Bowl (Body resonance) - adds sustain and warmth
 */
struct TheAbyss : FaustModule<VCVRackDSP> {
    enum ParamId {
        PITCH_PARAM,
        PRESSURE_PARAM,
        SLOSH_PARAM,
        DECAY_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        VOCT_INPUT,
        GATE_INPUT,      // Controls bow velocity
        SLOSH_CV_INPUT,  // Agitate the water!
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    TheAbyss() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Configure parameters
        configParam(PITCH_PARAM, -2.0f, 8.0f, 0.0f, "Base Frequency", " V");
        configParam(PRESSURE_PARAM, 0.01f, 1.0f, 0.5f, "Bow Pressure", "%", 0.f, 100.f);
        configParam(SLOSH_PARAM, 0.0f, 1.0f, 0.2f, "Water Level", "%", 0.f, 100.f);
        configParam(DECAY_PARAM, 0.9f, 0.999f, 0.99f, "Resonance", "%", 0.f, 100.f);

        // Configure inputs
        configInput(VOCT_INPUT, "V/Oct");
        configInput(GATE_INPUT, "Gate (Bow)");
        configInput(SLOSH_CV_INPUT, "Water CV");

        // Configure outputs
        configOutput(LEFT_OUTPUT, "Left");
        configOutput(RIGHT_OUTPUT, "Right");

        // Faust params (alphabetical): decay=0, pressure=1, slosh=2, velocity=3, volts=4
        mapParam(DECAY_PARAM, 0);
        mapParam(PRESSURE_PARAM, 1);
        mapParam(SLOSH_PARAM, 2);
        // velocity=3 handled manually (from gate)
        mapParam(PITCH_PARAM, 4);
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Get pitch with V/Oct input
        float volts = params[PITCH_PARAM].getValue();
        if (inputs[VOCT_INPUT].isConnected()) {
            volts += inputs[VOCT_INPUT].getVoltage();
        }
        volts = clamp(volts, -2.f, 8.f);

        // Get bow velocity from gate
        // Gate controls how fast the bow moves - higher voltage = faster bowing
        float velocity = 0.0f;
        if (inputs[GATE_INPUT].isConnected()) {
            velocity = clamp(inputs[GATE_INPUT].getVoltage() / 10.0f, 0.f, 1.f);
        }

        // Get water slosh with CV modulation
        float slosh = params[SLOSH_PARAM].getValue();
        if (inputs[SLOSH_CV_INPUT].isConnected()) {
            slosh += inputs[SLOSH_CV_INPUT].getVoltage() * 0.1f;
        }
        slosh = clamp(slosh, 0.f, 1.f);

        // Get other parameters
        float pressure = params[PRESSURE_PARAM].getValue();
        float decay = params[DECAY_PARAM].getValue();

        // Update Faust parameters (alphabetical order)
        faustDsp.setParamValue(0, decay);      // decay
        faustDsp.setParamValue(1, pressure);   // pressure
        faustDsp.setParamValue(2, slosh);      // slosh
        faustDsp.setParamValue(3, velocity);   // velocity
        faustDsp.setParamValue(4, volts);      // volts

        // Process audio (no input, stereo output)
        float* nullInputs[1] = { nullptr };
        float outputL = 0.0f, outputR = 0.0f;
        float* outputPtrs[2] = { &outputL, &outputR };

        faustDsp.compute(1, nullInputs, outputPtrs);

        // Output - scale appropriately
        outputs[LEFT_OUTPUT].setVoltage(outputL * 5.0f);
        outputs[RIGHT_OUTPUT].setVoltage(outputR * 5.0f);
    }
};

struct TheAbyssWidget : ModuleWidget {
    TheAbyssWidget(TheAbyss* module) {
        setModule(module);
        setPanel(createPanel(asset::plugin(pluginInstance, "res/TheAbyss.svg")));

        // Screws (4HP)
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        float xCenter = box.size.x / 2.0f;
        float xLeft = xCenter - 15;
        float xRight = xCenter + 15;

        // Pitch knob (big) at top center
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(xCenter, 50), module, TheAbyss::PITCH_PARAM));

        // Pressure and Slosh side by side
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 105), module, TheAbyss::PRESSURE_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 105), module, TheAbyss::SLOSH_PARAM));

        // Decay centered
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xCenter, 160), module, TheAbyss::DECAY_PARAM));

        // CV Inputs
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 220), module, TheAbyss::VOCT_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 220), module, TheAbyss::GATE_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter, 265), module, TheAbyss::SLOSH_CV_INPUT));

        // Stereo Outputs
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xLeft, 320), module, TheAbyss::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xRight, 320), module, TheAbyss::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelTheAbyss = createModel<WiggleRoom::TheAbyss, WiggleRoom::TheAbyssWidget>("TheAbyss");
