/******************************************************************************
 * CHAOS FLUTE
 * Physical model of a flute with overblow chaos
 * Features internal "Lung" envelope and aggressive multiphonics
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#include "ImagePanel.hpp"
#define FAUST_MODULE_NAME ChaosFlute
#include "chaos_flute.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * ChaosFlute - Physical Flute Model with Chaos Controls
 *
 * A "circuit bent" flute physical model that can be pushed into
 * screaming multiphonics. Includes internal breath envelope ("Lung")
 * that handles the physics of breath control automatically.
 *
 * Inputs:
 *   - V/Oct: Pitch control (0V = C4)
 *   - Gate: Triggers the breath envelope
 *
 * Parameters:
 *   - Attack: Breath envelope attack time
 *   - Release: Breath envelope release time
 *   - Pressure: Blow pressure (>0.8 overblows, >1.0 screams)
 *   - Jet: Embouchure distance (timbre/chaos control)
 *   - Growl: Breath noise (singing while playing)
 */
struct ChaosFlute : FaustModule<VCVRackDSP> {
    enum ParamId {
        ATTACK_PARAM,
        RELEASE_PARAM,
        PRESSURE_PARAM,
        MOUTH_PARAM,
        GROWL_PARAM,
        REVERB_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        VOCT_INPUT,
        GATE_INPUT,
        PRESSURE_CV_INPUT,
        MOUTH_CV_INPUT,
        REVERB_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    ChaosFlute() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Configure parameters
        configParam(ATTACK_PARAM, 0.001f, 0.5f, 0.05f, "Attack", " s");
        configParam(RELEASE_PARAM, 0.01f, 5.0f, 0.5f, "Release", " s");
        configParam(PRESSURE_PARAM, 0.0f, 1.5f, 0.6f, "Pressure", "", 0.f, 100.f);
        configParam(MOUTH_PARAM, 0.1f, 0.9f, 0.5f, "Mouth Position", "%", 0.f, 100.f);
        configParam(GROWL_PARAM, 0.0f, 1.0f, 0.0f, "Growl", "%", 0.f, 100.f);
        configParam(REVERB_PARAM, 0.0f, 1.0f, 0.3f, "Reverb", "%", 0.f, 100.f);

        // Configure inputs
        configInput(VOCT_INPUT, "V/Oct");
        configInput(GATE_INPUT, "Gate");
        configInput(PRESSURE_CV_INPUT, "Pressure CV");
        configInput(MOUTH_CV_INPUT, "Mouth CV");
        configInput(REVERB_CV_INPUT, "Reverb CV");

        // Configure outputs
        configOutput(LEFT_OUTPUT, "Left");
        configOutput(RIGHT_OUTPUT, "Right");

        // Faust params (alphabetical): attack=0, gate=1, growl=2, mouth=3, pressure=4, release=5, reverb=6, volts=7
        mapParam(ATTACK_PARAM, 0);
        mapParam(RELEASE_PARAM, 5);
        mapParam(PRESSURE_PARAM, 4);
        mapParam(MOUTH_PARAM, 3);
        mapParam(GROWL_PARAM, 2);
        mapParam(REVERB_PARAM, 6);
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Get V/Oct and Gate inputs
        float voct = inputs[VOCT_INPUT].getVoltage();
        float gate = inputs[GATE_INPUT].getVoltage();

        // Get attack (no CV)
        float attack = params[ATTACK_PARAM].getValue();

        // Get release (no CV)
        float release = params[RELEASE_PARAM].getValue();

        // Get pressure with CV modulation
        float pressure = params[PRESSURE_PARAM].getValue();
        if (inputs[PRESSURE_CV_INPUT].isConnected()) {
            pressure += inputs[PRESSURE_CV_INPUT].getVoltage() * 0.15f;  // ±10V = ±1.5
        }
        pressure = clamp(pressure, 0.f, 2.0f);  // Allow higher for extreme chaos

        // Get mouth position with CV modulation
        float mouth = params[MOUTH_PARAM].getValue();
        if (inputs[MOUTH_CV_INPUT].isConnected()) {
            mouth += inputs[MOUTH_CV_INPUT].getVoltage() * 0.08f;  // ±10V = ±0.8
        }
        mouth = clamp(mouth, 0.1f, 0.9f);

        // Get growl (no CV)
        float growl = params[GROWL_PARAM].getValue();

        // Get reverb with CV modulation
        float reverb = params[REVERB_PARAM].getValue();
        if (inputs[REVERB_CV_INPUT].isConnected()) {
            reverb += inputs[REVERB_CV_INPUT].getVoltage() * 0.1f;  // ±10V = ±1.0
        }
        reverb = clamp(reverb, 0.f, 1.f);

        // Update Faust parameters (alphabetical order)
        faustDsp.setParamValue(0, attack);    // attack
        faustDsp.setParamValue(1, gate);      // gate
        faustDsp.setParamValue(2, growl);     // growl
        faustDsp.setParamValue(3, mouth);     // mouth
        faustDsp.setParamValue(4, pressure);  // pressure
        faustDsp.setParamValue(5, release);   // release
        faustDsp.setParamValue(6, reverb);    // reverb
        faustDsp.setParamValue(7, voct);      // volts

        // Process audio (no input, stereo output)
        float* nullInputs[1] = { nullptr };
        float outputL = 0.0f, outputR = 0.0f;
        float* outputPtrs[2] = { &outputL, &outputR };

        faustDsp.compute(1, nullInputs, outputPtrs);

        // Output at 5V peak
        outputs[LEFT_OUTPUT].setVoltage(outputL * 5.0f);
        outputs[RIGHT_OUTPUT].setVoltage(outputR * 5.0f);
    }
};

struct ChaosFluteWidget : ModuleWidget {
    ChaosFluteWidget(ChaosFlute* module) {
        setModule(module);
        box.size = Vec(4 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);
        addChild(new WiggleRoom::ImagePanel(
            asset::plugin(pluginInstance, "res/ChaosFlute.png"), box.size));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        float xCenter = box.size.x / 2.0f;
        float xLeft = xCenter - 18;
        float xRight = xCenter + 18;

        // LUNG section - Attack/Release at top
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xLeft, 52), module, ChaosFlute::ATTACK_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xRight, 52), module, ChaosFlute::RELEASE_PARAM));

        // CHAOS section - Main Pressure knob
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(xCenter, 100), module, ChaosFlute::PRESSURE_PARAM));

        // Mouth and Growl knobs
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xLeft, 145), module, ChaosFlute::MOUTH_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xRight, 145), module, ChaosFlute::GROWL_PARAM));

        // Reverb knob
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xCenter, 180), module, ChaosFlute::REVERB_PARAM));

        // CV Inputs (3 inputs)
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 218), module, ChaosFlute::PRESSURE_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter, 218), module, ChaosFlute::MOUTH_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 218), module, ChaosFlute::REVERB_CV_INPUT));

        // V/Oct and Gate inputs
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 265), module, ChaosFlute::VOCT_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 265), module, ChaosFlute::GATE_INPUT));

        // Stereo Outputs
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xLeft, 320), module, ChaosFlute::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xRight, 320), module, ChaosFlute::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelChaosFlute = createModel<WiggleRoom::ChaosFlute, WiggleRoom::ChaosFluteWidget>("ChaosFlute");
