/******************************************************************************
 * NUT SHAKER
 * Stochastic Percussion Synthesizer
 * Uses PhISM (Physically Informed Stochastic Modeling) to simulate
 * particles colliding inside a resonant shell.
 *
 * Morphs from: Single woodblock clicks -> Nut cluster -> Maraca/egg shaker
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#include "ImagePanel.hpp"
#define FAUST_MODULE_NAME NutShaker
#include "nutshaker.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * NutShaker - Stochastic Percussion Synthesizer
 *
 * Unlike modal synthesis (bells, marimbas), this uses probability clouds
 * to generate organic, non-repeating particle collision textures.
 *
 * Character depends on Density and Pitch:
 *   - Low density (1-5) + Low pitch = Single nut drops (claves/woodblock)
 *   - Medium density (40-80) + Low pitch = Nut cluster (goat hooves)
 *   - High density (300+) + High pitch = Maraca/egg shaker
 *
 * Inputs:
 *   - Gate: Trigger the shake
 *   - V/Oct: Pitch control for shell resonance
 *
 * Parameters:
 *   - Force: Shake intensity (amplitude)
 *   - Duration: Shake envelope length
 *   - Density: Collisions per second
 *   - Chaos: Timing randomness
 *   - Pitch: Shell resonance frequency
 *   - Resonance: Shell Q/decay time
 *   - Spread: Harmonic irregularity
 *   - Mix: Dry clicks vs resonated
 */
struct NutShaker : FaustModule<VCVRackDSP> {
    enum ParamId {
        FORCE_PARAM,
        DURATION_PARAM,
        DENSITY_PARAM,
        CHAOS_PARAM,
        PITCH_PARAM,
        RESONANCE_PARAM,
        SPREAD_PARAM,
        MIX_PARAM,
        LEVEL_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        GATE_INPUT,
        VOCT_INPUT,
        FORCE_CV_INPUT,
        DENSITY_CV_INPUT,
        PITCH_CV_INPUT,
        RESONANCE_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    NutShaker() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Configure parameters
        configParam(FORCE_PARAM, 0.0f, 1.0f, 0.8f, "Shake Force", "%", 0.f, 100.f);
        configParam(DURATION_PARAM, 0.05f, 2.0f, 0.3f, "Shake Duration", " s");

        auto* densityParam = configParam(DENSITY_PARAM, 1.0f, 500.0f, 60.0f, "Seed Density", " /s");
        densityParam->description = "1-5=Single clicks, 40-80=Nut cluster, 300+=Maraca";

        configParam(CHAOS_PARAM, 0.0f, 1.0f, 0.6f, "Chaos", "%", 0.f, 100.f);
        configParam(PITCH_PARAM, 200.0f, 6000.0f, 1200.0f, "Nut Size", " Hz");
        configParam(RESONANCE_PARAM, 1.0f, 40.0f, 8.0f, "Shell Resonance");
        configParam(SPREAD_PARAM, 0.0f, 1.0f, 0.35f, "Harmonic Spread", "%", 0.f, 100.f);
        configParam(MIX_PARAM, 0.0f, 1.0f, 0.7f, "Mix", "%", 0.f, 100.f);
        configParam(LEVEL_PARAM, 0.0f, 1.0f, 0.8f, "Level", "%", 0.f, 100.f);

        // Configure inputs
        configInput(GATE_INPUT, "Gate");
        configInput(VOCT_INPUT, "V/Oct (Shell Pitch)");
        configInput(FORCE_CV_INPUT, "Force CV");
        configInput(DENSITY_CV_INPUT, "Density CV");
        configInput(PITCH_CV_INPUT, "Pitch CV");
        configInput(RESONANCE_CV_INPUT, "Resonance CV");

        // Configure outputs
        configOutput(LEFT_OUTPUT, "Left");
        configOutput(RIGHT_OUTPUT, "Right");

        // Map VCV parameters to Faust DSP parameters (alphabetical order)
        // Faust params: 0=chaos, 1=density, 2=duration, 3=force, 4=gate,
        //               5=level, 6=mix, 7=pitch, 8=resonance, 9=spread, 10=voct
        mapParam(CHAOS_PARAM, 0);
        mapParam(DENSITY_PARAM, 1);
        mapParam(DURATION_PARAM, 2);
        mapParam(FORCE_PARAM, 3);
        mapParam(LEVEL_PARAM, 5);
        mapParam(MIX_PARAM, 6);
        mapParam(PITCH_PARAM, 7);
        mapParam(RESONANCE_PARAM, 8);
        mapParam(SPREAD_PARAM, 9);

        // Map CV inputs
        mapCVInput(FORCE_CV_INPUT, 3, false, 0.1f);       // ±50% at ±5V
        mapCVInput(DENSITY_CV_INPUT, 1, false, 50.0f);    // ±250/s at ±5V
        mapCVInput(PITCH_CV_INPUT, 7, true, 1.0f);        // V/Oct exponential
        mapCVInput(RESONANCE_CV_INPUT, 8, false, 4.0f);   // ±20 Q at ±5V
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Get V/Oct and Gate inputs and send directly to Faust
        float voct = inputs[VOCT_INPUT].getVoltage();
        float gate = inputs[GATE_INPUT].getVoltage();

        // Set Faust parameters for inputs
        faustDsp.setParamValue(10, voct);  // voct
        faustDsp.setParamValue(4, gate);   // gate

        // Update all mapped parameters with CV modulation
        updateFaustParams();

        // Process audio (no input, stereo output)
        float* nullInputs[1] = { nullptr };
        float outputL = 0.0f, outputR = 0.0f;
        float* outputPtrs[2] = { &outputL, &outputR };

        faustDsp.compute(1, nullInputs, outputPtrs);

        // Output at 5V peak
        outputs[LEFT_OUTPUT].setVoltage(outputL * 5.0f);
        outputs[RIGHT_OUTPUT].setVoltage(outputR * 5.0f);
    }
};

struct NutShakerWidget : ModuleWidget {
    NutShakerWidget(NutShaker* module) {
        setModule(module);

        // Set module size (8HP)
        box.size = Vec(8 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);

        // Add PNG faceplate background
        addChild(new WiggleRoom::ImagePanel(
            asset::plugin(pluginInstance, "res/NutShaker.png"), box.size));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        float xCenter = box.size.x / 2.0f;
        float xLeft = 25.0f;
        float xRight = box.size.x - 25.0f;

        // Row 1: Density (big knob) - main character control
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(xCenter, 70), module, NutShaker::DENSITY_PARAM));

        // Row 2: Force + Duration
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 120), module, NutShaker::FORCE_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 120), module, NutShaker::DURATION_PARAM));

        // Row 3: Pitch + Resonance
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 165), module, NutShaker::PITCH_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 165), module, NutShaker::RESONANCE_PARAM));

        // Row 4: Chaos + Spread + Mix (small)
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xLeft, 205), module, NutShaker::CHAOS_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xCenter, 205), module, NutShaker::SPREAD_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xRight, 205), module, NutShaker::MIX_PARAM));

        // Row 5: CV inputs
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 250), module, NutShaker::FORCE_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter, 250), module, NutShaker::DENSITY_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 250), module, NutShaker::PITCH_CV_INPUT));

        // Row 6: Gate + V/Oct + Resonance CV
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 295), module, NutShaker::GATE_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter, 295), module, NutShaker::VOCT_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 295), module, NutShaker::RESONANCE_CV_INPUT));

        // Row 7: Level + Outputs
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xCenter, 335), module, NutShaker::LEVEL_PARAM));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xLeft, 350), module, NutShaker::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xRight, 350), module, NutShaker::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelNutShaker = createModel<WiggleRoom::NutShaker, WiggleRoom::NutShakerWidget>("NutShaker");
