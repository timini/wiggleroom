/******************************************************************************
 * INFINITE FOLDER
 * West Coast wavefolder for complex harmonic generation
 * Turns simple sine/triangle waves into aggressive, metallic timbres
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#include "ImagePanel.hpp"
#define FAUST_MODULE_NAME InfiniteFolder
#include "infinite_folder.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * InfiniteFolder - Sine-based Wavefolder
 *
 * A West Coast synthesis staple that creates complex harmonics by
 * folding the waveform back onto itself using a sine function.
 *
 * Inputs:
 *   - Audio In: Signal to fold (works best with sine/triangle)
 *   - Drive CV: Modulate fold intensity
 *   - Symmetry CV: Modulate DC offset (even harmonics)
 *
 * Parameters:
 *   - Drive: Fold intensity (1x-10x, CV can push to 20x)
 *   - Symmetry: DC offset before folding (-1 to +1)
 *   - Mix: Dry/wet blend
 */
struct InfiniteFolder : FaustModule<VCVRackDSP> {
    enum ParamId {
        DRIVE_PARAM,
        SYMMETRY_PARAM,
        MIX_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        AUDIO_INPUT,
        DRIVE_CV_INPUT,
        SYMMETRY_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        AUDIO_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    InfiniteFolder() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Configure parameters
        configParam(DRIVE_PARAM, 1.0f, 10.0f, 1.0f, "Drive", "x");
        configParam(SYMMETRY_PARAM, -1.0f, 1.0f, 0.0f, "Symmetry");
        configParam(MIX_PARAM, 0.0f, 1.0f, 1.0f, "Mix", "%", 0.f, 100.f);

        // Configure inputs
        configInput(AUDIO_INPUT, "Audio");
        configInput(DRIVE_CV_INPUT, "Drive CV");
        configInput(SYMMETRY_CV_INPUT, "Symmetry CV");

        // Configure outputs
        configOutput(AUDIO_OUTPUT, "Audio");

        // Faust params (alphabetical): drive=0, mix=1, symmetry=2
        mapParam(DRIVE_PARAM, 0);
        mapParam(MIX_PARAM, 1);
        mapParam(SYMMETRY_PARAM, 2);
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Get drive with CV modulation
        // Knob: 1-10x, CV can push to 20x for extreme destruction
        float drive = params[DRIVE_PARAM].getValue();
        if (inputs[DRIVE_CV_INPUT].isConnected()) {
            drive += inputs[DRIVE_CV_INPUT].getVoltage();  // 1V = +1x
        }
        drive = clamp(drive, 1.f, 20.f);

        // Get symmetry with CV modulation
        float symmetry = params[SYMMETRY_PARAM].getValue();
        if (inputs[SYMMETRY_CV_INPUT].isConnected()) {
            symmetry += inputs[SYMMETRY_CV_INPUT].getVoltage() * 0.1f;  // ±10V = ±1.0
        }
        symmetry = clamp(symmetry, -1.f, 1.f);

        // Get mix
        float mix = params[MIX_PARAM].getValue();

        // Update Faust parameters (alphabetical order)
        faustDsp.setParamValue(0, drive);     // drive
        faustDsp.setParamValue(1, mix);       // mix
        faustDsp.setParamValue(2, symmetry);  // symmetry

        // Get input and scale down
        // VCV signals are ±5V, scale to ±1.0 for clean folding math
        float input = inputs[AUDIO_INPUT].getVoltage() * 0.2f;

        // Process audio
        float output = 0.0f;
        float* inputPtrs[1] = { &input };
        float* outputPtrs[1] = { &output };

        faustDsp.compute(1, inputPtrs, outputPtrs);

        // Scale output back to modular level (±5V)
        outputs[AUDIO_OUTPUT].setVoltage(output * 5.0f);
    }
};

struct InfiniteFolderWidget : ModuleWidget {
    InfiniteFolderWidget(InfiniteFolder* module) {
        setModule(module);
        box.size = Vec(2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);
        addChild(new WiggleRoom::ImagePanel(
            asset::plugin(pluginInstance, "res/InfiniteFolder.png"), box.size));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        float xCenter = box.size.x / 2.0f;
        float xLeft = xCenter - 12;
        float xRight = xCenter + 12;

        // Main Drive knob at top (big)
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(xCenter, 55), module, InfiniteFolder::DRIVE_PARAM));

        // Symmetry and Mix knobs
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xLeft, 105), module, InfiniteFolder::SYMMETRY_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xRight, 105), module, InfiniteFolder::MIX_PARAM));

        // CV Inputs
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 160), module, InfiniteFolder::DRIVE_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 160), module, InfiniteFolder::SYMMETRY_CV_INPUT));

        // Audio Input
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter, 230), module, InfiniteFolder::AUDIO_INPUT));

        // Audio Output
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xCenter, 310), module, InfiniteFolder::AUDIO_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelInfiniteFolder = createModel<WiggleRoom::InfiniteFolder, WiggleRoom::InfiniteFolderWidget>("InfiniteFolder");
