/******************************************************************************
 * SPECTRAHENGE
 * 4-Channel Spatial/Spectral Mixer
 * X/Y grid: X = equal-power pan, Y = SVF filter morph (LP→BP→HP)
 * Interactive display with 4 draggable nodes, per-node CV, 2 global LFOs
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#include "ImagePanel.hpp"
#include <cmath>
#define FAUST_MODULE_NAME SpectraHenge
#include "spectra_henge.hpp"  // Generated by Faust

#include <atomic>

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

// Node colors (RGBA for NanoVG)
static const NVGcolor NODE_COLORS[4] = {
    nvgRGBA(0, 200, 255, 255),   // Channel 1: Cyan
    nvgRGBA(255, 80, 180, 255),  // Channel 2: Magenta
    nvgRGBA(255, 180, 0, 255),   // Channel 3: Orange
    nvgRGBA(120, 255, 80, 255),  // Channel 4: Green
};

static const NVGcolor NODE_GLOW_COLORS[4] = {
    nvgRGBA(0, 200, 255, 60),
    nvgRGBA(255, 80, 180, 60),
    nvgRGBA(255, 180, 0, 60),
    nvgRGBA(120, 255, 80, 60),
};

// ============================================================================
// MODULE
// ============================================================================

struct SpectraHenge : FaustModule<VCVRackDSP> {
    enum ParamId {
        NODE_X1_PARAM,
        NODE_X2_PARAM,
        NODE_X3_PARAM,
        NODE_X4_PARAM,
        NODE_Y1_PARAM,
        NODE_Y2_PARAM,
        NODE_Y3_PARAM,
        NODE_Y4_PARAM,
        Q_PARAM,
        SEND_PARAM,      // Send amount (0-1)
        PARAMS_LEN
    };
    enum InputId {
        IN1_INPUT,
        IN2_INPUT,
        IN3_INPUT,
        IN4_INPUT,
        CV_X1_INPUT,
        CV_X2_INPUT,
        CV_X3_INPUT,
        CV_X4_INPUT,
        CV_Y1_INPUT,
        CV_Y2_INPUT,
        CV_Y3_INPUT,
        CV_Y4_INPUT,
        LFO_A_INPUT,
        LFO_B_INPUT,
        IN1_R_INPUT,     // Stereo right inputs
        IN2_R_INPUT,
        IN3_R_INPUT,
        IN4_R_INPUT,
        RETURN_L_INPUT,  // Effects return
        RETURN_R_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        OUT_L_OUTPUT,
        OUT_R_OUTPUT,
        SEND_L_OUTPUT,   // Effects send
        SEND_R_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    // Thread-safe display positions (written by audio, read by UI)
    std::atomic<float> displayX[4];
    std::atomic<float> displayY[4];

    SpectraHenge() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Hidden X/Y params (set by display drag)
        configParam(NODE_X1_PARAM, 0.f, 1.f, 0.25f, "Node 1 X");
        configParam(NODE_X2_PARAM, 0.f, 1.f, 0.75f, "Node 2 X");
        configParam(NODE_X3_PARAM, 0.f, 1.f, 0.25f, "Node 3 X");
        configParam(NODE_X4_PARAM, 0.f, 1.f, 0.75f, "Node 4 X");
        configParam(NODE_Y1_PARAM, 0.f, 1.f, 0.25f, "Node 1 Y");
        configParam(NODE_Y2_PARAM, 0.f, 1.f, 0.75f, "Node 2 Y");
        configParam(NODE_Y3_PARAM, 0.f, 1.f, 0.75f, "Node 3 Y");
        configParam(NODE_Y4_PARAM, 0.f, 1.f, 0.25f, "Node 4 Y");

        // Visible Q knob
        configParam(Q_PARAM, 0.5f, 10.f, 1.0f, "Resonance (Q)");

        // Send amount
        configParam(SEND_PARAM, 0.f, 1.f, 0.f, "Send", "%", 0.f, 100.f);

        // Audio inputs
        configInput(IN1_INPUT, "Audio 1");
        configInput(IN2_INPUT, "Audio 2");
        configInput(IN3_INPUT, "Audio 3");
        configInput(IN4_INPUT, "Audio 4");

        // Stereo right inputs
        configInput(IN1_R_INPUT, "Audio 1 Right");
        configInput(IN2_R_INPUT, "Audio 2 Right");
        configInput(IN3_R_INPUT, "Audio 3 Right");
        configInput(IN4_R_INPUT, "Audio 4 Right");

        // CV inputs
        configInput(CV_X1_INPUT, "Node 1 X CV");
        configInput(CV_X2_INPUT, "Node 2 X CV");
        configInput(CV_X3_INPUT, "Node 3 X CV");
        configInput(CV_X4_INPUT, "Node 4 X CV");
        configInput(CV_Y1_INPUT, "Node 1 Y CV");
        configInput(CV_Y2_INPUT, "Node 2 Y CV");
        configInput(CV_Y3_INPUT, "Node 3 Y CV");
        configInput(CV_Y4_INPUT, "Node 4 Y CV");

        // LFO inputs
        configInput(LFO_A_INPUT, "LFO A (global X drift)");
        configInput(LFO_B_INPUT, "LFO B (global Y drift)");

        // Effects loop
        configInput(RETURN_L_INPUT, "Return Left");
        configInput(RETURN_R_INPUT, "Return Right");

        // Stereo outputs
        configOutput(OUT_L_OUTPUT, "Left");
        configOutput(OUT_R_OUTPUT, "Right");
        configOutput(SEND_L_OUTPUT, "Send Left");
        configOutput(SEND_R_OUTPUT, "Send Right");

        // Initialize display positions
        for (int i = 0; i < 4; i++) {
            displayX[i].store(0.5f);
            displayY[i].store(0.5f);
        }

        // No mapParam/mapCVInput — we handle everything manually in process()
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // LFO global offsets: ±5V → ±0.25
        float lfoA = inputs[LFO_A_INPUT].getVoltage() * 0.05f;
        float lfoB = inputs[LFO_B_INPUT].getVoltage() * 0.05f;

        // Param index arrays for iteration
        static const int xParams[4] = {NODE_X1_PARAM, NODE_X2_PARAM, NODE_X3_PARAM, NODE_X4_PARAM};
        static const int yParams[4] = {NODE_Y1_PARAM, NODE_Y2_PARAM, NODE_Y3_PARAM, NODE_Y4_PARAM};
        static const int cvXInputs[4] = {CV_X1_INPUT, CV_X2_INPUT, CV_X3_INPUT, CV_X4_INPUT};
        static const int cvYInputs[4] = {CV_Y1_INPUT, CV_Y2_INPUT, CV_Y3_INPUT, CV_Y4_INPUT};

        float finalX[4], finalY[4];

        for (int i = 0; i < 4; i++) {
            // Base position from param (set by knob/drag)
            float baseX = params[xParams[i]].getValue();
            float baseY = params[yParams[i]].getValue();

            // Add CV (±10V → ±1.0 range)
            float cvX = inputs[cvXInputs[i]].getVoltage() * 0.1f;
            float cvY = inputs[cvYInputs[i]].getVoltage() * 0.1f;

            // Add LFO global drift
            finalX[i] = clamp(baseX + cvX + lfoA, 0.f, 1.f);
            finalY[i] = clamp(baseY + cvY + lfoB, 0.f, 1.f);

            // Update display atomics for UI thread
            displayX[i].store(finalX[i], std::memory_order_relaxed);
            displayY[i].store(finalY[i], std::memory_order_relaxed);
        }

        // Set Faust parameters (alphabetical index order):
        // 0=pan1, 1=pan2, 2=pan3, 3=pan4, 4=q, 5=tilt1, 6=tilt2, 7=tilt3, 8=tilt4
        faustDsp.setParamValue(0, finalX[0]);  // pan1
        faustDsp.setParamValue(1, finalX[1]);  // pan2
        faustDsp.setParamValue(2, finalX[2]);  // pan3
        faustDsp.setParamValue(3, finalX[3]);  // pan4
        faustDsp.setParamValue(4, params[Q_PARAM].getValue());  // q
        faustDsp.setParamValue(5, finalY[0]);  // tilt1
        faustDsp.setParamValue(6, finalY[1]);  // tilt2
        faustDsp.setParamValue(7, finalY[2]);  // tilt3
        faustDsp.setParamValue(8, finalY[3]);  // tilt4

        // Audio I/O — sum stereo inputs to mono (R optional, backward compatible)
        float in1 = inputs[IN1_INPUT].getVoltage();
        if (inputs[IN1_R_INPUT].isConnected())
            in1 += inputs[IN1_R_INPUT].getVoltage();
        in1 *= 0.2f;

        float in2 = inputs[IN2_INPUT].getVoltage();
        if (inputs[IN2_R_INPUT].isConnected())
            in2 += inputs[IN2_R_INPUT].getVoltage();
        in2 *= 0.2f;

        float in3 = inputs[IN3_INPUT].getVoltage();
        if (inputs[IN3_R_INPUT].isConnected())
            in3 += inputs[IN3_R_INPUT].getVoltage();
        in3 *= 0.2f;

        float in4 = inputs[IN4_INPUT].getVoltage();
        if (inputs[IN4_R_INPUT].isConnected())
            in4 += inputs[IN4_R_INPUT].getVoltage();
        in4 *= 0.2f;

        float* inputPtrs[4] = {&in1, &in2, &in3, &in4};
        float outL = 0.f, outR = 0.f;
        float* outputPtrs[2] = {&outL, &outR};

        faustDsp.compute(1, inputPtrs, outputPtrs);

        // Send outputs (pre-limiter, raw Faust output)
        outputs[SEND_L_OUTPUT].setVoltage(outL * 5.f);
        outputs[SEND_R_OUTPUT].setVoltage(outR * 5.f);

        // Mix return and apply limiter (tanh moved from Faust to C++)
        float sendAmt = params[SEND_PARAM].getValue();
        float retL = inputs[RETURN_L_INPUT].getVoltage() * 0.2f;
        float retR = inputs[RETURN_R_INPUT].getVoltage() * 0.2f;
        float finalL = std::tanh(outL + retL * sendAmt);
        float finalR = std::tanh(outR + retR * sendAmt);
        outputs[OUT_L_OUTPUT].setVoltage(finalL * 5.f);
        outputs[OUT_R_OUTPUT].setVoltage(finalR * 5.f);
    }
};

// ============================================================================
// DISPLAY WIDGET (Interactive X/Y grid with 4 draggable nodes)
// ============================================================================

struct SpectraHengeDisplay : OpaqueWidget {
    SpectraHenge* module = nullptr;
    int dragNode = -1;  // Which node is being dragged (-1 = none)
    int hoverNode = -1; // Which node is being hovered

    static constexpr float NODE_RADIUS = 8.f;
    static constexpr float HIT_RADIUS = 16.f;

    SpectraHengeDisplay() {}

    // Get node position in widget coordinates
    Vec getNodePos(int i) {
        float x = 0.5f, y = 0.5f;
        if (module) {
            x = module->displayX[i].load(std::memory_order_relaxed);
            y = module->displayY[i].load(std::memory_order_relaxed);
        }
        // Y is inverted: tilt=0 (LPF) at bottom, tilt=1 (HPF) at top
        return Vec(x * box.size.x, (1.f - y) * box.size.y);
    }

    // Hit-test: find closest node within radius
    int hitTestNode(Vec pos) {
        for (int i = 0; i < 4; i++) {
            Vec nodePos = getNodePos(i);
            if (pos.minus(nodePos).norm() < HIT_RADIUS) {
                return i;
            }
        }
        return -1;
    }

    void onButton(const ButtonEvent& e) override {
        if (e.button == GLFW_MOUSE_BUTTON_LEFT && e.action == GLFW_PRESS) {
            int hit = hitTestNode(e.pos);
            if (hit >= 0) {
                dragNode = hit;
                e.consume(this);
                return;
            }
        }
        OpaqueWidget::onButton(e);
    }

    void onDragStart(const DragStartEvent& e) override {
        // dragNode already set in onButton
    }

    void onDragMove(const DragMoveEvent& e) override {
        if (dragNode < 0 || !module) return;

        // Convert pixel delta to normalized delta
        float dx = e.mouseDelta.x / box.size.x;
        float dy = -e.mouseDelta.y / box.size.y;  // Y inverted

        // Get current param values and update
        int xParamId = SpectraHenge::NODE_X1_PARAM + dragNode;
        int yParamId = SpectraHenge::NODE_Y1_PARAM + dragNode;

        float newX = clamp(module->params[xParamId].getValue() + dx, 0.f, 1.f);
        float newY = clamp(module->params[yParamId].getValue() + dy, 0.f, 1.f);

        APP->engine->setParamValue(module, xParamId, newX);
        APP->engine->setParamValue(module, yParamId, newY);
    }

    void onDragEnd(const DragEndEvent& e) override {
        dragNode = -1;
    }

    void onHover(const HoverEvent& e) override {
        hoverNode = hitTestNode(e.pos);
        OpaqueWidget::onHover(e);
    }

    void onLeave(const LeaveEvent& e) override {
        hoverNode = -1;
        OpaqueWidget::onLeave(e);
    }

    // Layer 0: opaque background
    void draw(const DrawArgs& args) override {
        // Dark background
        nvgBeginPath(args.vg);
        nvgRoundedRect(args.vg, 0, 0, box.size.x, box.size.y, 4.f);
        nvgFillColor(args.vg, nvgRGB(10, 8, 20));
        nvgFill(args.vg);

        OpaqueWidget::draw(args);
    }

    // Layer 1: lit content (nodes, grid, labels)
    void drawLayer(const DrawArgs& args, int layer) override {
        if (layer != 1) {
            OpaqueWidget::drawLayer(args, layer);
            return;
        }

        float w = box.size.x;
        float h = box.size.y;

        // Grid lines
        nvgStrokeColor(args.vg, nvgRGBA(60, 50, 80, 80));
        nvgStrokeWidth(args.vg, 0.5f);

        // Vertical lines (pan zones)
        for (int i = 1; i < 4; i++) {
            float x = w * i / 4.f;
            nvgBeginPath(args.vg);
            nvgMoveTo(args.vg, x, 0);
            nvgLineTo(args.vg, x, h);
            nvgStroke(args.vg);
        }

        // Horizontal lines (filter zones)
        for (int i = 1; i < 3; i++) {
            float y = h * i / 3.f;
            nvgBeginPath(args.vg);
            nvgMoveTo(args.vg, 0, y);
            nvgLineTo(args.vg, w, y);
            nvgStroke(args.vg);
        }

        // Zone labels
        nvgFontSize(args.vg, 8.f);
        nvgTextAlign(args.vg, NVG_ALIGN_CENTER | NVG_ALIGN_MIDDLE);
        nvgFillColor(args.vg, nvgRGBA(80, 70, 110, 100));

        nvgText(args.vg, w * 0.5f, h * 1.f / 6.f, "HPF", NULL);
        nvgText(args.vg, w * 0.5f, h * 0.5f, "BPF", NULL);
        nvgText(args.vg, w * 0.5f, h * 5.f / 6.f, "LPF", NULL);

        nvgFontSize(args.vg, 7.f);
        nvgFillColor(args.vg, nvgRGBA(60, 50, 90, 80));
        nvgTextAlign(args.vg, NVG_ALIGN_LEFT | NVG_ALIGN_BOTTOM);
        nvgText(args.vg, 2.f, h - 2.f, "L", NULL);
        nvgTextAlign(args.vg, NVG_ALIGN_RIGHT | NVG_ALIGN_BOTTOM);
        nvgText(args.vg, w - 2.f, h - 2.f, "R", NULL);

        // Draw connection lines between nodes (subtle)
        if (module) {
            nvgStrokeColor(args.vg, nvgRGBA(60, 50, 80, 30));
            nvgStrokeWidth(args.vg, 0.5f);
            for (int i = 0; i < 4; i++) {
                for (int j = i + 1; j < 4; j++) {
                    Vec a = getNodePos(i);
                    Vec b = getNodePos(j);
                    nvgBeginPath(args.vg);
                    nvgMoveTo(args.vg, a.x, a.y);
                    nvgLineTo(args.vg, b.x, b.y);
                    nvgStroke(args.vg);
                }
            }
        }

        // Draw nodes
        for (int i = 0; i < 4; i++) {
            Vec pos = getNodePos(i);
            bool isDragging = (dragNode == i);
            bool isHovering = (hoverNode == i);
            float radius = NODE_RADIUS;

            if (isDragging) radius *= 1.3f;
            else if (isHovering) radius *= 1.15f;

            // Glow
            float glowRadius = radius * 3.f;
            NVGpaint glow = nvgRadialGradient(args.vg,
                pos.x, pos.y, radius * 0.5f, glowRadius,
                NODE_GLOW_COLORS[i], nvgRGBA(0, 0, 0, 0));
            nvgBeginPath(args.vg);
            nvgCircle(args.vg, pos.x, pos.y, glowRadius);
            nvgFillPaint(args.vg, glow);
            nvgFill(args.vg);

            // Node circle
            nvgBeginPath(args.vg);
            nvgCircle(args.vg, pos.x, pos.y, radius);
            nvgFillColor(args.vg, NODE_COLORS[i]);
            nvgFill(args.vg);

            // Inner highlight
            nvgBeginPath(args.vg);
            nvgCircle(args.vg, pos.x - radius * 0.2f, pos.y - radius * 0.2f, radius * 0.4f);
            nvgFillColor(args.vg, nvgRGBA(255, 255, 255, 80));
            nvgFill(args.vg);

            // Channel number
            nvgFontSize(args.vg, 9.f);
            nvgTextAlign(args.vg, NVG_ALIGN_CENTER | NVG_ALIGN_MIDDLE);
            nvgFillColor(args.vg, nvgRGB(0, 0, 0));
            char numBuf[2] = {(char)('1' + i), 0};
            nvgText(args.vg, pos.x, pos.y + 0.5f, numBuf, NULL);

            // Hover tooltip
            if (isDragging || isHovering) {
                float xVal = module ? module->displayX[i].load(std::memory_order_relaxed) : 0.5f;
                float yVal = module ? module->displayY[i].load(std::memory_order_relaxed) : 0.5f;

                char tooltip[32];
                snprintf(tooltip, sizeof(tooltip), "%.0f%% %.0f%%", xVal * 100.f, yVal * 100.f);

                nvgFontSize(args.vg, 8.f);
                nvgTextAlign(args.vg, NVG_ALIGN_CENTER | NVG_ALIGN_BOTTOM);
                nvgFillColor(args.vg, NODE_COLORS[i]);
                float tooltipY = pos.y - radius - 4.f;
                if (tooltipY < 10.f) tooltipY = pos.y + radius + 12.f;
                nvgText(args.vg, pos.x, tooltipY, tooltip, NULL);
            }
        }

        OpaqueWidget::drawLayer(args, layer);
    }
};

// ============================================================================
// MODULE WIDGET
// ============================================================================

struct SpectraHengeWidget : ModuleWidget {
    SpectraHengeWidget(SpectraHenge* module) {
        setModule(module);

        // 16HP panel
        box.size = Vec(16 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);

        // PNG faceplate background
        addChild(new WiggleRoom::ImagePanel(
            asset::plugin(pluginInstance, "res/SpectraHenge.png"), box.size));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        // Layout constants
        float centerX = box.size.x / 2.f;
        float displaySize = 120.f;
        float displayTop = 28.f;

        // --- X/Y Display ---
        SpectraHengeDisplay* display = new SpectraHengeDisplay();
        display->box.pos = Vec(centerX - displaySize / 2.f, displayTop);
        display->box.size = Vec(displaySize, displaySize);
        display->module = module;
        addChild(display);

        // --- Q and Send knobs below display ---
        float knobRow = displayTop + displaySize + 18.f;
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(centerX - 20.f, knobRow), module, SpectraHenge::Q_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(centerX + 20.f, knobRow), module, SpectraHenge::SEND_PARAM));

        // --- Jack layout ---
        float col1 = 28.f;
        float col2 = 68.f;
        float col3 = box.size.x - 68.f;
        float col4 = box.size.x - 28.f;

        float jackRow1 = 190.f;  // Audio L inputs
        float jackRowSpacing = 28.f;

        // Row 1: Audio Left inputs (IN 1-4 L)
        addInput(createInputCentered<PJ301MPort>(Vec(col1, jackRow1), module, SpectraHenge::IN1_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col2, jackRow1), module, SpectraHenge::IN2_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col3, jackRow1), module, SpectraHenge::IN3_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col4, jackRow1), module, SpectraHenge::IN4_INPUT));

        // Row 2: Audio Right inputs (IN 1-4 R)
        float jackRow2 = jackRow1 + jackRowSpacing;
        addInput(createInputCentered<PJ301MPort>(Vec(col1, jackRow2), module, SpectraHenge::IN1_R_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col2, jackRow2), module, SpectraHenge::IN2_R_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col3, jackRow2), module, SpectraHenge::IN3_R_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col4, jackRow2), module, SpectraHenge::IN4_R_INPUT));

        // Row 3: X CV inputs
        float jackRow3 = jackRow2 + jackRowSpacing;
        addInput(createInputCentered<PJ301MPort>(Vec(col1, jackRow3), module, SpectraHenge::CV_X1_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col2, jackRow3), module, SpectraHenge::CV_X2_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col3, jackRow3), module, SpectraHenge::CV_X3_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col4, jackRow3), module, SpectraHenge::CV_X4_INPUT));

        // Row 4: Y CV inputs
        float jackRow4 = jackRow3 + jackRowSpacing;
        addInput(createInputCentered<PJ301MPort>(Vec(col1, jackRow4), module, SpectraHenge::CV_Y1_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col2, jackRow4), module, SpectraHenge::CV_Y2_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col3, jackRow4), module, SpectraHenge::CV_Y3_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col4, jackRow4), module, SpectraHenge::CV_Y4_INPUT));

        // Row 5: LFO A, LFO B, Output L, Output R
        float jackRow5 = jackRow4 + jackRowSpacing;
        addInput(createInputCentered<PJ301MPort>(Vec(col1, jackRow5), module, SpectraHenge::LFO_A_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col2, jackRow5), module, SpectraHenge::LFO_B_INPUT));
        addOutput(createOutputCentered<PJ301MPort>(Vec(col3, jackRow5), module, SpectraHenge::OUT_L_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(Vec(col4, jackRow5), module, SpectraHenge::OUT_R_OUTPUT));

        // Row 6: Send L, Send R, Return L, Return R
        float jackRow6 = jackRow5 + jackRowSpacing;
        addOutput(createOutputCentered<PJ301MPort>(Vec(col1, jackRow6), module, SpectraHenge::SEND_L_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(Vec(col2, jackRow6), module, SpectraHenge::SEND_R_OUTPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col3, jackRow6), module, SpectraHenge::RETURN_L_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col4, jackRow6), module, SpectraHenge::RETURN_R_INPUT));
    }
};

} // namespace WiggleRoom

Model* modelSpectraHenge = createModel<WiggleRoom::SpectraHenge, WiggleRoom::SpectraHengeWidget>("SpectraHenge");
