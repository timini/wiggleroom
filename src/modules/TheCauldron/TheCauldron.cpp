/******************************************************************************
 * THE CAULDRON
 * Fluid Wave Math Processor - All math, no logic
 *
 * 4 inputs combined through 7 analog algorithms:
 *   - Mix (Sum): Standard mixing
 *   - Ring (Mult): Ring modulation
 *   - Peaks (Max): Trace the mountain tops
 *   - Valleys (Min): Trace the canyon floors
 *   - Diff (Subtract): Phase cancellation
 *   - Fold (Distort): Sum then wavefold
 *   - Morph (Vector): Smooth LFO-driven crossfade
 *
 * Built with Faust DSP
 ******************************************************************************/

#include "ImagePanel.hpp"

#include "rack.hpp"
#include "FaustModule.hpp"
#define FAUST_MODULE_NAME TheCauldron
#include "the_cauldron.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

// Mode names for display
static const std::vector<std::string> MODE_LABELS = {
    "Mix", "Ring", "Peaks", "Valleys", "Diff", "Fold", "Morph"
};

// Rate multiplier values - musical divisions and multiplications
static const std::vector<float> RATE_VALUES = {
    1.f/16.f, 1.f/12.f, 1.f/8.f, 1.f/6.f, 1.f/4.f, 1.f/3.f, 1.f/2.f, 2.f/3.f,
    1.f, 3.f/2.f, 2.f, 3.f, 4.f, 6.f, 8.f, 12.f, 16.f
};

static const std::vector<std::string> RATE_LABELS = {
    "/16", "/12", "/8", "/6", "/4", "/3", "/2", "/1.5",
    "x1", "x1.5", "x2", "x3", "x4", "x6", "x8", "x12", "x16"
};

struct TheCauldron : FaustModule<VCVRackDSP> {
    static constexpr int SCOPE_BUFFER_SIZE = 128;
    static constexpr int SCOPE_DOWNSAMPLE_RATE = 32;

    enum ParamId {
        MODE_PARAM,
        RATE_PARAM,  // Clock-synced rate for Morph, Drive for Fold
        PARAMS_LEN
    };
    enum InputId {
        IN_A,
        IN_B,
        IN_C,
        IN_D,
        CLOCK_INPUT,
        MODE_CV_INPUT,
        RATE_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        MAIN_OUTPUT,
        INV_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHT_A,
        LIGHT_B,
        LIGHT_C,
        LIGHT_D,
        LIGHTS_LEN
    };

    // Clock detection
    dsp::SchmittTrigger clockTrigger;
    float timeSinceClock = 0.f;
    float clockPeriod = 0.5f;  // Default 120 BPM
    bool clockDetected = false;

    // Scope buffer
    float scopeBuffer[SCOPE_BUFFER_SIZE] = {};
    int scopeWriteIndex = 0;
    int scopeDownsample = 0;

    TheCauldron() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Mode selector (snapped to integers)
        configSwitch(MODE_PARAM, 0.f, 6.f, 0.f, "Mode", MODE_LABELS);

        // Rate parameter (snapped to musical divisions) - default to x1
        configSwitch(RATE_PARAM, 0.f, RATE_VALUES.size() - 1, 8.f, "Rate", RATE_LABELS);

        // Inputs
        configInput(IN_A, "Signal A");
        configInput(IN_B, "Signal B");
        configInput(IN_C, "Signal C");
        configInput(IN_D, "Signal D");
        configInput(CLOCK_INPUT, "Clock");
        configInput(MODE_CV_INPUT, "Mode CV");
        configInput(RATE_CV_INPUT, "Rate CV");

        // Outputs
        configOutput(MAIN_OUTPUT, "Main");
        configOutput(INV_OUTPUT, "Inverted");

        // Faust params (alphabetical order): drive=0, mode=1, speed=2
        // These are set dynamically in process(), not mapped directly
        mapParam(MODE_PARAM, 1);
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        float dt = args.sampleTime;

        // Clock detection
        timeSinceClock += dt;
        if (clockTrigger.process(inputs[CLOCK_INPUT].getVoltage(), 0.1f, 1.f)) {
            if (timeSinceClock > 0.001f) {
                clockPeriod = timeSinceClock;
                clockDetected = true;
            }
            timeSinceClock = 0.f;
        }
        if (timeSinceClock > 3.f) {
            clockDetected = false;
        }

        // Get mode with CV modulation
        float mode = params[MODE_PARAM].getValue();
        if (inputs[MODE_CV_INPUT].isConnected()) {
            mode += inputs[MODE_CV_INPUT].getVoltage() * 0.7f;  // ~10V = full range
        }
        mode = clamp(mode, 0.f, 6.f);
        int modeInt = static_cast<int>(std::round(mode));

        // Get rate index with CV
        int rateIndex = static_cast<int>(params[RATE_PARAM].getValue());
        if (inputs[RATE_CV_INPUT].isConnected()) {
            rateIndex += static_cast<int>(inputs[RATE_CV_INPUT].getVoltage() * 1.7f);  // ~10V = full range
        }
        rateIndex = clamp(rateIndex, 0, (int)RATE_VALUES.size() - 1);
        float rateMultiplier = RATE_VALUES[rateIndex];

        // Calculate speed from clock period and rate multiplier
        // Speed in Hz = rateMultiplier / clockPeriod
        float speed = rateMultiplier / clockPeriod;

        // For Fold mode, use rate as drive intensity (1-5)
        float drive = 1.0f + (rateIndex / (float)(RATE_VALUES.size() - 1)) * 4.0f;

        // Update Faust parameters (alphabetical: drive=0, mode=1, speed=2)
        faustDsp.setParamValue(0, drive);
        faustDsp.setParamValue(1, static_cast<float>(modeInt));
        faustDsp.setParamValue(2, speed);

        // Get inputs (scale from ±5V to ±1.0 for cleaner math)
        float a = inputs[IN_A].getVoltage() * 0.2f;
        float b = inputs[IN_B].getVoltage() * 0.2f;
        float c = inputs[IN_C].getVoltage() * 0.2f;
        float d = inputs[IN_D].getVoltage() * 0.2f;

        // Process through Faust
        float output = 0.0f;
        float* inputPtrs[4] = { &a, &b, &c, &d };
        float* outputPtrs[1] = { &output };

        faustDsp.compute(1, inputPtrs, outputPtrs);

        // Scale output back to modular level (±5V)
        float outVoltage = output * 5.0f;
        outputs[MAIN_OUTPUT].setVoltage(outVoltage);
        outputs[INV_OUTPUT].setVoltage(-outVoltage);

        // Update scope buffer (downsampled)
        scopeDownsample++;
        if (scopeDownsample >= SCOPE_DOWNSAMPLE_RATE) {
            scopeDownsample = 0;
            scopeBuffer[scopeWriteIndex] = output;
            scopeWriteIndex = (scopeWriteIndex + 1) % SCOPE_BUFFER_SIZE;
        }

        // Update lights (show input activity)
        lights[LIGHT_A].setBrightness(std::abs(a) * 0.5f);
        lights[LIGHT_B].setBrightness(std::abs(b) * 0.5f);
        lights[LIGHT_C].setBrightness(std::abs(c) * 0.5f);
        lights[LIGHT_D].setBrightness(std::abs(d) * 0.5f);
    }
};

// Scope widget for displaying output waveform
struct CauldronScopeWidget : Widget {
    TheCauldron* module;
    NVGcolor waveColor;

    CauldronScopeWidget() {
        waveColor = nvgRGB(0x00, 0xff, 0x80);  // Green
    }

    void draw(const DrawArgs& args) override {
        // Background
        nvgBeginPath(args.vg);
        nvgRect(args.vg, 0, 0, box.size.x, box.size.y);
        nvgFillColor(args.vg, nvgRGB(0x0a, 0x0a, 0x0a));
        nvgFill(args.vg);

        // Border
        nvgStrokeColor(args.vg, nvgRGB(0x33, 0x33, 0x33));
        nvgStrokeWidth(args.vg, 1.0f);
        nvgStroke(args.vg);

        // Center line
        nvgBeginPath(args.vg);
        nvgMoveTo(args.vg, 0, box.size.y / 2);
        nvgLineTo(args.vg, box.size.x, box.size.y / 2);
        nvgStrokeColor(args.vg, nvgRGB(0x25, 0x25, 0x25));
        nvgStrokeWidth(args.vg, 0.5f);
        nvgStroke(args.vg);
    }

    void drawLayer(const DrawArgs& args, int layer) override {
        if (layer != 1) return;
        if (!module) return;

        // Draw waveform
        nvgBeginPath(args.vg);

        int bufferSize = TheCauldron::SCOPE_BUFFER_SIZE;
        int startIndex = module->scopeWriteIndex;

        for (int i = 0; i < bufferSize; i++) {
            int idx = (startIndex + i) % bufferSize;
            float sample = module->scopeBuffer[idx];

            float x = (float)i / (bufferSize - 1) * box.size.x;
            float y = (1.f - sample) * 0.5f * box.size.y;
            y = clamp(y, 1.f, box.size.y - 1.f);

            if (i == 0) {
                nvgMoveTo(args.vg, x, y);
            } else {
                nvgLineTo(args.vg, x, y);
            }
        }

        nvgStrokeColor(args.vg, waveColor);
        nvgStrokeWidth(args.vg, 1.5f);
        nvgStroke(args.vg);

        Widget::drawLayer(args, layer);
    }
};

struct TheCauldronWidget : ModuleWidget {
    TheCauldronWidget(TheCauldron* module) {
        setModule(module);
        box.size = Vec(3 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);
        addChild(new WiggleRoom::ImagePanel(
            asset::plugin(pluginInstance, "res/TheCauldron.png"), box.size));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        // Clock input at top left
        addInput(createInputCentered<PJ301MPort>(
            mm2px(Vec(8, 15)), module, TheCauldron::CLOCK_INPUT));

        // Mode knob at top center-right
        addParam(createParamCentered<RoundBigBlackKnob>(
            mm2px(Vec(26, 18)), module, TheCauldron::MODE_PARAM));

        // Rate knob (clock-synced)
        addParam(createParamCentered<RoundBlackKnob>(
            mm2px(Vec(20.32, 38)), module, TheCauldron::RATE_PARAM));

        // Scope display
        CauldronScopeWidget* scope = new CauldronScopeWidget();
        scope->module = module;
        scope->box.pos = mm2px(Vec(3, 48));
        scope->box.size = mm2px(Vec(34.64, 15));
        addChild(scope);

        // 4 Signal Inputs in 2x2 grid
        float inputY1 = 72.f;
        float inputY2 = 86.f;

        // Input A with light
        addInput(createInputCentered<PJ301MPort>(
            mm2px(Vec(10, inputY1)), module, TheCauldron::IN_A));
        addChild(createLightCentered<SmallLight<GreenLight>>(
            mm2px(Vec(10, inputY1 - 6)), module, TheCauldron::LIGHT_A));

        // Input B with light
        addInput(createInputCentered<PJ301MPort>(
            mm2px(Vec(30, inputY1)), module, TheCauldron::IN_B));
        addChild(createLightCentered<SmallLight<GreenLight>>(
            mm2px(Vec(30, inputY1 - 6)), module, TheCauldron::LIGHT_B));

        // Input C with light
        addInput(createInputCentered<PJ301MPort>(
            mm2px(Vec(10, inputY2)), module, TheCauldron::IN_C));
        addChild(createLightCentered<SmallLight<GreenLight>>(
            mm2px(Vec(10, inputY2 - 6)), module, TheCauldron::LIGHT_C));

        // Input D with light
        addInput(createInputCentered<PJ301MPort>(
            mm2px(Vec(30, inputY2)), module, TheCauldron::IN_D));
        addChild(createLightCentered<SmallLight<GreenLight>>(
            mm2px(Vec(30, inputY2 - 6)), module, TheCauldron::LIGHT_D));

        // CV Inputs
        addInput(createInputCentered<PJ301MPort>(
            mm2px(Vec(10, 100)), module, TheCauldron::MODE_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            mm2px(Vec(30, 100)), module, TheCauldron::RATE_CV_INPUT));

        // Outputs at bottom
        addOutput(createOutputCentered<PJ301MPort>(
            mm2px(Vec(10, 116)), module, TheCauldron::MAIN_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            mm2px(Vec(30, 116)), module, TheCauldron::INV_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelTheCauldron = createModel<WiggleRoom::TheCauldron, WiggleRoom::TheCauldronWidget>("TheCauldron");
