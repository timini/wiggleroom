/******************************************************************************
 * ACID9Voice
 * TB-303 inspired acid synthesizer voice with modern enhancements
 *
 * Features:
 * - Tri-core morphing oscillator (saw/sharktooth/square)
 * - ISOTOPE detune/stereo spread control
 * - Sub oscillator (sine/square)
 * - Pre-filter GRIT saturation
 * - Dual filters (ACID diode ladder / LEAD OTA)
 * - Filter envelope with accent boost
 * - Insert loop (send/return)
 * - Stereo delay with clock sync and ghost mode
 * - Slide (portamento) control
 *
 * Part of the WiggleRoom VCV Rack plugin
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#include "ImagePanel.hpp"
#define FAUST_MODULE_NAME ACID9Voice
#include "acid9voice.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * ACID9Voice - TB-303 Inspired Acid Synthesizer Voice
 *
 * A modern take on the classic acid sound with extended capabilities.
 *
 * Signal Flow:
 *   Tri-Core Osc + Sub -> Grit -> Filter -> VCA -> Insert Loop -> Delay -> Output
 *
 * Inputs:
 *   - V/OCT: Pitch control (0V = C4)
 *   - GATE: Note on/off
 *   - ACCENT: Boosts filter env and VCA
 *   - SLIDE: Enables portamento when high
 *   - CUTOFF_CV: Filter cutoff modulation
 *   - FM_IN: Frequency modulation
 *   - CLOCK: Clock for delay sync
 *   - RETURN: Insert loop return (normalizes to send when unpatched)
 *   - SHAPE_CV: Shape (waveform morph) modulation
 *   - ISOTOPE_CV: Isotope (detune/spread) modulation
 *   - DECAY_CV: Decay (filter envelope) modulation
 *
 * Outputs:
 *   - LEFT/RIGHT: Main stereo output
 *   - SEND: Insert loop send (post-VCA, pre-delay)
 */
struct ACID9Voice : FaustModule<VCVRackDSP> {
    enum ParamId {
        // Oscillator section
        SHAPE_PARAM,
        ISOTOPE_PARAM,
        SUB_LEVEL_PARAM,
        SUB_MODE_PARAM,
        // Filter section
        CUTOFF_PARAM,
        RESONANCE_PARAM,
        ENV_MOD_PARAM,
        DECAY_PARAM,
        FILTER_MODE_PARAM,
        GRIT_PARAM,
        // Delay section
        DELAY_TIME_PARAM,
        DELAY_FB_PARAM,
        DELAY_MIX_PARAM,
        DELAY_RATIO_PARAM,
        DELAY_GHOST_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        VOCT_INPUT,
        GATE_INPUT,
        ACCENT_INPUT,
        SLIDE_INPUT,
        CUTOFF_CV_INPUT,
        FM_INPUT,
        CLOCK_INPUT,
        RETURN_INPUT,
        SHAPE_CV_INPUT,
        ISOTOPE_CV_INPUT,
        DECAY_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        SEND_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        FILTER_MODE_LIGHT,  // Shows ACID (off) / LEAD (on)
        LIGHTS_LEN
    };

    // Clock tracking for delay sync
    float lastClockVoltage = 0.f;
    float clockPeriodSamples = 0.f;
    float samplesSinceLastClock = 0.f;
    bool clockSynced = false;

    ACID9Voice() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Oscillator section
        configParam(SHAPE_PARAM, 0.f, 1.f, 0.f, "Shape", "", 0.f, 100.f);
        configParam(ISOTOPE_PARAM, 0.f, 1.f, 0.f, "Isotope", "%", 0.f, 100.f);
        configParam(SUB_LEVEL_PARAM, 0.f, 1.f, 0.f, "Sub Level", "%", 0.f, 100.f);
        configSwitch(SUB_MODE_PARAM, 0.f, 1.f, 0.f, "Sub Mode", {"Sine", "Square"});

        // Filter section
        configParam(CUTOFF_PARAM, 20.f, 20000.f, 1000.f, "Cutoff", " Hz");
        configParam(RESONANCE_PARAM, 0.f, 1.f, 0.3f, "Resonance", "%", 0.f, 100.f);
        configParam(ENV_MOD_PARAM, -1.f, 1.f, 0.5f, "Env Mod", "%", 0.f, 100.f);
        configParam(DECAY_PARAM, 0.01f, 2.f, 0.3f, "Decay", " s");
        configSwitch(FILTER_MODE_PARAM, 0.f, 1.f, 0.f, "Filter Mode", {"ACID", "LEAD"});
        configParam(GRIT_PARAM, 0.f, 1.f, 0.f, "Grit", "%", 0.f, 100.f);

        // Delay section
        configParam(DELAY_TIME_PARAM, 10.f, 2000.f, 250.f, "Delay Time", " ms");
        configParam(DELAY_FB_PARAM, 0.f, 0.95f, 0.3f, "Delay Feedback", "%", 0.f, 105.26f);
        configParam(DELAY_MIX_PARAM, 0.f, 1.f, 0.f, "Delay Mix", "%", 0.f, 100.f);
        configSwitch(DELAY_RATIO_PARAM, 0.f, 4.f, 2.f, "Delay Ratio", {"/4", "/2", "x1", "x2", "x4"});
        configParam(DELAY_GHOST_PARAM, 0.f, 1.f, 0.f, "Ghost", "%", 0.f, 100.f);

        // Inputs
        configInput(VOCT_INPUT, "V/Oct");
        configInput(GATE_INPUT, "Gate");
        configInput(ACCENT_INPUT, "Accent");
        configInput(SLIDE_INPUT, "Slide");
        configInput(CUTOFF_CV_INPUT, "Cutoff CV");
        configInput(FM_INPUT, "FM");
        configInput(CLOCK_INPUT, "Clock");
        configInput(RETURN_INPUT, "Insert Return");
        configInput(SHAPE_CV_INPUT, "Shape CV");
        configInput(ISOTOPE_CV_INPUT, "Isotope CV");
        configInput(DECAY_CV_INPUT, "Decay CV");

        // Outputs
        configOutput(LEFT_OUTPUT, "Left");
        configOutput(RIGHT_OUTPUT, "Right");
        configOutput(SEND_OUTPUT, "Insert Send");

        // Light
        configLight(FILTER_MODE_LIGHT, "Filter Mode (ACID/LEAD)");

        // Faust parameter indices (ALPHABETICAL ORDER):
        // NOTE: delay_ratio was optimized out by Faust (defined but unused)
        // accent=0, cutoff=1, cutoff_cv=2, decay=3, delay_fb=4, delay_ghost=5,
        // delay_mix=6, delay_time=7, env_mod=8, filter_mode=9, fm_in=10,
        // gate=11, grit=12, isotope=13, resonance=14, return_connected=15,
        // return_in_l=16, return_in_r=17, shape=18, slide=19, sub_level=20,
        // sub_mode=21, volts=22

        // Map VCV params to Faust params (not using mapParam for complex CV handling)
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Clock tracking for delay sync
        float clockVoltage = inputs[CLOCK_INPUT].getVoltage();
        bool clockRising = (clockVoltage > 0.5f) && (lastClockVoltage <= 0.5f);
        lastClockVoltage = clockVoltage;

        if (clockRising) {
            if (samplesSinceLastClock > 100.f) {  // Ignore very short periods
                clockPeriodSamples = samplesSinceLastClock;
                clockSynced = true;
            }
            samplesSinceLastClock = 0.f;
        }
        samplesSinceLastClock += 1.f;

        // Decay clock sync if no clock received
        if (samplesSinceLastClock > args.sampleRate * 2.f) {
            clockSynced = false;
        }

        // Get inputs
        float voct = inputs[VOCT_INPUT].getVoltage();
        float gate = inputs[GATE_INPUT].getVoltage();
        float accent = inputs[ACCENT_INPUT].getVoltage();
        float slide = inputs[SLIDE_INPUT].getVoltage();
        float cutoffCV = inputs[CUTOFF_CV_INPUT].getVoltage();
        float fmIn = inputs[FM_INPUT].getVoltage();

        // Insert return (mono for now, could be stereo)
        float returnL = inputs[RETURN_INPUT].getVoltage() * 0.2f;  // Convert to ±1
        float returnR = returnL;
        float returnConnected = inputs[RETURN_INPUT].isConnected() ? 1.f : 0.f;

        // Get parameter values
        float shape = params[SHAPE_PARAM].getValue();
        float isotope = params[ISOTOPE_PARAM].getValue();
        float subLevel = params[SUB_LEVEL_PARAM].getValue();
        float subMode = params[SUB_MODE_PARAM].getValue();

        float cutoff = params[CUTOFF_PARAM].getValue();
        float resonance = params[RESONANCE_PARAM].getValue();
        float envMod = params[ENV_MOD_PARAM].getValue();
        float decay = params[DECAY_PARAM].getValue();
        float filterMode = params[FILTER_MODE_PARAM].getValue();
        float grit = params[GRIT_PARAM].getValue();

        // Apply CV modulation to shape, isotope, and decay
        // Shape: 0-1 range, ±5V maps to ±0.5 (half range modulation)
        float shapeFinal = clamp(shape + inputs[SHAPE_CV_INPUT].getVoltage() / 10.f, 0.f, 1.f);
        // Isotope: 0-1 range, ±5V maps to ±0.5 (half range modulation)
        float isotopeFinal = clamp(isotope + inputs[ISOTOPE_CV_INPUT].getVoltage() / 10.f, 0.f, 1.f);
        // Decay: 0.01-2.0 range, ±5V maps to ±1.0s modulation
        float decayFinal = clamp(decay + inputs[DECAY_CV_INPUT].getVoltage() / 5.f, 0.01f, 2.f);

        float delayTime = params[DELAY_TIME_PARAM].getValue();
        float delayFb = params[DELAY_FB_PARAM].getValue();
        float delayMix = params[DELAY_MIX_PARAM].getValue();
        float delayRatio = params[DELAY_RATIO_PARAM].getValue();
        float delayGhost = params[DELAY_GHOST_PARAM].getValue();

        // Calculate delay time (sync or manual)
        float actualDelayTime = delayTime;
        if (clockSynced && clockPeriodSamples > 0.f) {
            // Convert ratio index to multiplier
            float ratioMult = 1.f;
            switch (static_cast<int>(delayRatio)) {
                case 0: ratioMult = 0.25f; break;
                case 1: ratioMult = 0.5f; break;
                case 2: ratioMult = 1.f; break;
                case 3: ratioMult = 2.f; break;
                case 4: ratioMult = 4.f; break;
            }
            actualDelayTime = (clockPeriodSamples * ratioMult / args.sampleRate) * 1000.f;
            actualDelayTime = clamp(actualDelayTime, 10.f, 2000.f);
        }

        // Set Faust parameters (alphabetical order - delay_ratio optimized out!)
        faustDsp.setParamValue(0, accent);           // accent
        faustDsp.setParamValue(1, cutoff);           // cutoff
        faustDsp.setParamValue(2, cutoffCV);         // cutoff_cv
        faustDsp.setParamValue(3, decayFinal);        // decay (with CV)
        faustDsp.setParamValue(4, delayFb);          // delay_fb
        faustDsp.setParamValue(5, delayGhost);       // delay_ghost
        faustDsp.setParamValue(6, delayMix);         // delay_mix
        faustDsp.setParamValue(7, actualDelayTime);  // delay_time
        faustDsp.setParamValue(8, envMod);           // env_mod
        faustDsp.setParamValue(9, filterMode);       // filter_mode
        faustDsp.setParamValue(10, fmIn);            // fm_in
        faustDsp.setParamValue(11, gate);            // gate
        faustDsp.setParamValue(12, grit);            // grit
        faustDsp.setParamValue(13, isotopeFinal);     // isotope (with CV)
        faustDsp.setParamValue(14, resonance);       // resonance
        faustDsp.setParamValue(15, returnConnected); // return_connected
        faustDsp.setParamValue(16, returnL);         // return_in_l
        faustDsp.setParamValue(17, returnR);         // return_in_r
        faustDsp.setParamValue(18, shapeFinal);       // shape (with CV)
        faustDsp.setParamValue(19, slide);           // slide
        faustDsp.setParamValue(20, subLevel);        // sub_level
        faustDsp.setParamValue(21, subMode);         // sub_mode
        faustDsp.setParamValue(22, voct);            // volts

        // Process audio (no input, 3 outputs: L, R, Send)
        float* nullInputs[1] = { nullptr };
        float outputL = 0.0f, outputR = 0.0f, outputSend = 0.0f;
        float* outputPtrs[3] = { &outputL, &outputR, &outputSend };

        faustDsp.compute(1, nullInputs, outputPtrs);

        // Output at 5V peak
        outputs[LEFT_OUTPUT].setVoltage(outputL * 5.0f);
        outputs[RIGHT_OUTPUT].setVoltage(outputR * 5.0f);
        outputs[SEND_OUTPUT].setVoltage(outputSend * 5.0f);

        // Update filter mode light
        lights[FILTER_MODE_LIGHT].setBrightness(filterMode);
    }
};

struct ACID9VoiceWidget : ModuleWidget {
    ACID9VoiceWidget(ACID9Voice* module) {
        setModule(module);
        box.size = Vec(20 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);
        addChild(new WiggleRoom::ImagePanel(
            asset::plugin(pluginInstance, "res/ACID9Voice.png"), box.size));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        // Layout constants
        float col1 = 30.f;
        float col2 = 75.f;
        float col3 = 120.f;
        float col4 = 165.f;
        float col5 = 210.f;
        float col6 = 255.f;

        // === OSC SECTION (top left) ===
        float oscY = 55.f;
        addParam(createParamCentered<RoundBigBlackKnob>(Vec(col1, oscY), module, ACID9Voice::SHAPE_PARAM));
        addParam(createParamCentered<RoundBigBlackKnob>(Vec(col2, oscY), module, ACID9Voice::ISOTOPE_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(Vec(col1, oscY + 45), module, ACID9Voice::SUB_LEVEL_PARAM));
        addParam(createParamCentered<CKSS>(Vec(col2, oscY + 45), module, ACID9Voice::SUB_MODE_PARAM));

        // === FILTER SECTION (top middle) ===
        float filterY = 55.f;
        addParam(createParamCentered<RoundBigBlackKnob>(Vec(col3, filterY), module, ACID9Voice::CUTOFF_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(Vec(col4, filterY), module, ACID9Voice::RESONANCE_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(Vec(col3, filterY + 45), module, ACID9Voice::ENV_MOD_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(Vec(col4, filterY + 45), module, ACID9Voice::DECAY_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(Vec((col3 + col4) / 2, filterY + 85), module, ACID9Voice::GRIT_PARAM));

        // Filter mode switch with light
        addParam(createParamCentered<CKSS>(Vec(col4 + 25, filterY + 85), module, ACID9Voice::FILTER_MODE_PARAM));
        addChild(createLightCentered<SmallLight<GreenLight>>(Vec(col4 + 40, filterY + 85), module, ACID9Voice::FILTER_MODE_LIGHT));

        // === DELAY SECTION (top right) ===
        float delayY = 55.f;
        addParam(createParamCentered<RoundBlackKnob>(Vec(col5, delayY), module, ACID9Voice::DELAY_TIME_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(Vec(col6, delayY), module, ACID9Voice::DELAY_FB_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(Vec(col5, delayY + 45), module, ACID9Voice::DELAY_MIX_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(Vec(col6, delayY + 45), module, ACID9Voice::DELAY_GHOST_PARAM));

        // Delay ratio (snap knob)
        auto* ratioKnob = createParamCentered<RoundSmallBlackKnob>(Vec((col5 + col6) / 2, delayY + 85), module, ACID9Voice::DELAY_RATIO_PARAM);
        ratioKnob->snap = true;
        addParam(ratioKnob);

        // === CV INPUTS (middle row) ===
        float cvY = 200.f;
        addInput(createInputCentered<PJ301MPort>(Vec(col1, cvY), module, ACID9Voice::CUTOFF_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col2, cvY), module, ACID9Voice::FM_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col3, cvY), module, ACID9Voice::CLOCK_INPUT));

        // === INSERT LOOP (middle row) ===
        addOutput(createOutputCentered<PJ301MPort>(Vec(col5, cvY), module, ACID9Voice::SEND_OUTPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col6, cvY), module, ACID9Voice::RETURN_INPUT));

        // === ADDITIONAL CV INPUTS (second CV row) ===
        float cvY2 = 237.f;
        addInput(createInputCentered<PJ301MPort>(Vec(col1, cvY2), module, ACID9Voice::SHAPE_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col2, cvY2), module, ACID9Voice::ISOTOPE_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col3, cvY2), module, ACID9Voice::DECAY_CV_INPUT));

        // === MAIN INPUTS (bottom) ===
        float inputY = 270.f;
        addInput(createInputCentered<PJ301MPort>(Vec(col1, inputY), module, ACID9Voice::VOCT_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col2, inputY), module, ACID9Voice::GATE_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col3, inputY), module, ACID9Voice::ACCENT_INPUT));
        addInput(createInputCentered<PJ301MPort>(Vec(col4, inputY), module, ACID9Voice::SLIDE_INPUT));

        // === OUTPUTS (bottom right) ===
        float outputY = 320.f;
        addOutput(createOutputCentered<PJ301MPort>(Vec(col5, outputY), module, ACID9Voice::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(Vec(col6, outputY), module, ACID9Voice::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelACID9Voice = createModel<WiggleRoom::ACID9Voice, WiggleRoom::ACID9VoiceWidget>("ACID9Voice");
