/******************************************************************************
 * MODAL BELL
 * Morphing Percussion Synthesizer - Wood Block to Glockenspiel
 * Uses modal synthesis with 5-instrument interpolation
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#include "ImagePanel.hpp"
#define FAUST_MODULE_NAME ModalBell
#include "modal_bell.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * ModalBell - Morphing Percussion Synthesizer
 *
 * A physically modeled percussion instrument that morphs between:
 *   0.00 = Wood Block (inharmonic, hollow, short decay)
 *   0.25 = Marimba (harmonic 1:4 ratio, warm wood)
 *   0.50 = Vibraphone (harmonic, singing metal, long decay)
 *   0.75 = Kalimba (anharmonic, clamped tine buzz)
 *   1.00 = Glockenspiel (stiff steel bar, piercing)
 *
 * Inputs:
 *   - V/Oct: Pitch control (0V = C4)
 *   - Gate: Trigger input (strikes when > 0.5V)
 *
 * Parameters:
 *   - Morph: Instrument type (main macro control)
 *   - Brightness: Harmonic content
 *   - Damping: Choke the sound (0=ring, 1=muted)
 *   - Strike: Position on bar (0=edge, 0.5=center)
 *   - Velocity: Mallet hardness (0=soft wool, 1=hard metal)
 */
struct ModalBell : FaustModule<VCVRackDSP> {
    enum ParamId {
        MORPH_PARAM,
        BRIGHTNESS_PARAM,
        DAMPING_PARAM,
        STRIKE_PARAM,
        VELOCITY_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        VOCT_INPUT,
        GATE_INPUT,
        MORPH_CV_INPUT,
        BRIGHTNESS_CV_INPUT,
        DAMPING_CV_INPUT,
        STRIKE_CV_INPUT,
        VELOCITY_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    ModalBell() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Configure parameters
        // Morph is the main macro control - labels show instrument positions
        auto* morphParam = configParam(MORPH_PARAM, 0.0f, 1.0f, 0.25f, "Morph");
        morphParam->description = "0=Wood Block, 0.25=Marimba, 0.5=Vibraphone, 0.75=Kalimba, 1=Glockenspiel";

        configParam(BRIGHTNESS_PARAM, 0.0f, 1.0f, 0.5f, "Brightness", "%", 0.f, 100.f);
        configParam(DAMPING_PARAM, 0.0f, 1.0f, 0.0f, "Damping", "%", 0.f, 100.f);
        configParam(STRIKE_PARAM, 0.03f, 0.5f, 0.3f, "Strike Position", "%", 0.f, 200.f);
        configParam(VELOCITY_PARAM, 0.0f, 1.0f, 0.8f, "Velocity", "%", 0.f, 100.f);

        // Configure inputs
        configInput(VOCT_INPUT, "V/Oct");
        configInput(GATE_INPUT, "Gate");
        configInput(MORPH_CV_INPUT, "Morph CV");
        configInput(BRIGHTNESS_CV_INPUT, "Brightness CV");
        configInput(DAMPING_CV_INPUT, "Damping CV");
        configInput(STRIKE_CV_INPUT, "Strike CV");
        configInput(VELOCITY_CV_INPUT, "Velocity CV");

        // Configure outputs
        configOutput(LEFT_OUTPUT, "Left");
        configOutput(RIGHT_OUTPUT, "Right");

        // Map VCV parameters to Faust DSP parameters (alphabetical order)
        // Faust params: 0=brightness, 1=damping, 2=gate, 3=morph, 4=strike, 5=velocity, 6=volts
        mapParam(BRIGHTNESS_PARAM, 0);
        mapParam(DAMPING_PARAM, 1);
        mapParam(MORPH_PARAM, 3);
        mapParam(STRIKE_PARAM, 4);
        mapParam(VELOCITY_PARAM, 5);

        // Map CV inputs (±5V modulation)
        mapCVInput(BRIGHTNESS_CV_INPUT, 0, false, 0.1f);   // ±50% at ±5V
        mapCVInput(DAMPING_CV_INPUT, 1, false, 0.1f);      // ±50% at ±5V
        mapCVInput(MORPH_CV_INPUT, 3, false, 0.1f);        // ±50% at ±5V
        mapCVInput(STRIKE_CV_INPUT, 4, false, 0.05f);      // ±25% at ±5V (0-0.5 range)
        mapCVInput(VELOCITY_CV_INPUT, 5, false, 0.1f);     // ±50% at ±5V
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Get V/Oct and Gate inputs and send directly to Faust
        float voct = inputs[VOCT_INPUT].getVoltage();
        float gate = inputs[GATE_INPUT].getVoltage();

        // Set Faust parameters for inputs
        // Faust params: 0=brightness, 1=damping, 2=gate, 3=morph, 4=strike, 5=velocity, 6=volts
        faustDsp.setParamValue(6, voct);   // volts
        faustDsp.setParamValue(2, gate);   // gate

        // Update all mapped parameters with CV modulation
        updateFaustParams();

        // Process audio (no input, stereo output)
        float* nullInputs[1] = { nullptr };
        float outputL = 0.0f, outputR = 0.0f;
        float* outputPtrs[2] = { &outputL, &outputR };

        faustDsp.compute(1, nullInputs, outputPtrs);

        // Output at 5V peak
        outputs[LEFT_OUTPUT].setVoltage(outputL * 5.0f);
        outputs[RIGHT_OUTPUT].setVoltage(outputR * 5.0f);
    }
};

struct ModalBellWidget : ModuleWidget {
    ModalBellWidget(ModalBell* module) {
        setModule(module);

        // Set module size (8HP)
        box.size = Vec(8 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);

        // Add PNG faceplate background
        addChild(new WiggleRoom::ImagePanel(
            asset::plugin(pluginInstance, "res/ModalBell.png"), box.size));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        float xCenter = box.size.x / 2.0f;
        float xLeft = 25.0f;
        float xRight = box.size.x - 25.0f;

        // Row 1: Morph (big knob) - the main macro control
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(xCenter, 70), module, ModalBell::MORPH_PARAM));

        // Row 2: Brightness + Velocity (small knobs)
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 120), module, ModalBell::BRIGHTNESS_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 120), module, ModalBell::VELOCITY_PARAM));

        // Row 3: Strike + Damping (small knobs)
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 165), module, ModalBell::STRIKE_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 165), module, ModalBell::DAMPING_PARAM));

        // Row 4: CV inputs for main params
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter, 210), module, ModalBell::MORPH_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 235), module, ModalBell::BRIGHTNESS_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 235), module, ModalBell::VELOCITY_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 270), module, ModalBell::STRIKE_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 270), module, ModalBell::DAMPING_CV_INPUT));

        // Row 5: V/Oct and Gate
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 310), module, ModalBell::VOCT_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 310), module, ModalBell::GATE_INPUT));

        // Row 6: Outputs
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xLeft, 350), module, ModalBell::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xRight, 350), module, ModalBell::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelModalBell = createModel<WiggleRoom::ModalBell, WiggleRoom::ModalBellWidget>("ModalBell");
