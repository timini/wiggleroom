/******************************************************************************
 * MODAL BELL
 * Physical model of a struck bar - Vibraphone, Marimba, Bell sounds
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#include "ImagePanel.hpp"
#define FAUST_MODULE_NAME ModalBell
#include "modal_bell.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * ModalBell - Physical Model of a Struck Bar
 *
 * A physically modeled instrument that sounds like a Vibraphone,
 * Marimba, or glassy bell depending on the knob settings.
 *
 * Inputs:
 *   - V/Oct: Pitch control (0V = C4)
 *   - Gate: Trigger input (strikes when > 1V)
 *
 * Parameters:
 *   - Hardness: Mallet softness (0 = soft, 1 = hard)
 *   - Position: Strike position on bar (0 = edge, 1 = center)
 *   - Preset: Instrument type (Marimba, Vibraphone, etc.)
 */
struct ModalBell : FaustModule<VCVRackDSP> {
    enum ParamId {
        BRIGHTNESS_PARAM,
        DECAY_PARAM,
        MATERIAL_PARAM,
        STRIKE_PARAM,
        VELOCITY_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        VOCT_INPUT,
        GATE_INPUT,
        BRIGHTNESS_CV_INPUT,
        DECAY_CV_INPUT,
        MATERIAL_CV_INPUT,
        STRIKE_CV_INPUT,
        VELOCITY_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    ModalBell() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Configure parameters
        configParam(BRIGHTNESS_PARAM, 0.0f, 1.0f, 0.5f, "Brightness", "%", 0.f, 100.f);
        configParam(DECAY_PARAM, 0.1f, 5.0f, 0.5f, "Decay", " s");
        configParam(MATERIAL_PARAM, 0.0f, 1.0f, 0.5f, "Material", "%", 0.f, 100.f);
        configParam(STRIKE_PARAM, 0.0f, 1.0f, 0.3f, "Strike Position", "%", 0.f, 100.f);
        configParam(VELOCITY_PARAM, 0.0f, 1.0f, 0.8f, "Velocity", "%", 0.f, 100.f);

        // Configure inputs
        configInput(VOCT_INPUT, "V/Oct");
        configInput(GATE_INPUT, "Gate");
        configInput(BRIGHTNESS_CV_INPUT, "Brightness CV");
        configInput(DECAY_CV_INPUT, "Decay CV");
        configInput(MATERIAL_CV_INPUT, "Material CV");
        configInput(STRIKE_CV_INPUT, "Strike CV");
        configInput(VELOCITY_CV_INPUT, "Velocity CV");

        // Configure outputs
        configOutput(LEFT_OUTPUT, "Left");
        configOutput(RIGHT_OUTPUT, "Right");

        // Map VCV parameters to Faust DSP parameters (alphabetical order)
        // Faust params: 0=brightness, 1=decay, 2=gate, 3=material, 4=strike, 5=velocity, 6=volts
        mapParam(BRIGHTNESS_PARAM, 0);
        mapParam(DECAY_PARAM, 1);
        mapParam(MATERIAL_PARAM, 3);
        mapParam(STRIKE_PARAM, 4);
        mapParam(VELOCITY_PARAM, 5);

        // Map CV inputs (±5V = ±100% modulation for 0-1 params, ±5V for decay)
        mapCVInput(BRIGHTNESS_CV_INPUT, 0, false, 0.1f);  // ±50% at ±5V
        mapCVInput(DECAY_CV_INPUT, 1, false, 0.2f);       // ±1s at ±5V
        mapCVInput(MATERIAL_CV_INPUT, 3, false, 0.1f);
        mapCVInput(STRIKE_CV_INPUT, 4, false, 0.1f);
        mapCVInput(VELOCITY_CV_INPUT, 5, false, 0.1f);
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Get V/Oct and Gate inputs and send directly to Faust
        float voct = inputs[VOCT_INPUT].getVoltage();
        float gate = inputs[GATE_INPUT].getVoltage();

        // Set Faust parameters for inputs
        // Faust params: 0=brightness, 1=decay, 2=gate, 3=material, 4=strike, 5=velocity, 6=volts
        faustDsp.setParamValue(6, voct);   // volts
        faustDsp.setParamValue(2, gate);   // gate

        // Update all mapped parameters with CV modulation
        updateFaustParams();

        // Process audio (no input, stereo output)
        float* nullInputs[1] = { nullptr };
        float outputL = 0.0f, outputR = 0.0f;
        float* outputPtrs[2] = { &outputL, &outputR };

        faustDsp.compute(1, nullInputs, outputPtrs);

        // Output at 5V peak
        outputs[LEFT_OUTPUT].setVoltage(outputL * 5.0f);
        outputs[RIGHT_OUTPUT].setVoltage(outputR * 5.0f);
    }
};

struct ModalBellWidget : ModuleWidget {
    ModalBellWidget(ModalBell* module) {
        setModule(module);

        // Set module size (8HP)
        box.size = Vec(8 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);

        // Add PNG faceplate background
        addChild(new WiggleRoom::ImagePanel(
            asset::plugin(pluginInstance, "res/ModalBell.png"), box.size));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        float xCenter = box.size.x / 2.0f;
        float xLeft = 25.0f;
        float xRight = box.size.x - 25.0f;

        // Row 1: Decay (big knob) - moved down to not cover title
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(xCenter, 70), module, ModalBell::DECAY_PARAM));

        // Row 2: Brightness + Material (small knobs)
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 120), module, ModalBell::BRIGHTNESS_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 120), module, ModalBell::MATERIAL_PARAM));

        // Row 3: Strike + Velocity (small knobs)
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 165), module, ModalBell::STRIKE_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 165), module, ModalBell::VELOCITY_PARAM));

        // Row 4: CV inputs for all params
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter, 210), module, ModalBell::DECAY_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 235), module, ModalBell::BRIGHTNESS_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 235), module, ModalBell::MATERIAL_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 270), module, ModalBell::STRIKE_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 270), module, ModalBell::VELOCITY_CV_INPUT));

        // Row 5: V/Oct and Gate
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 310), module, ModalBell::VOCT_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 310), module, ModalBell::GATE_INPUT));

        // Row 6: Outputs
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xLeft, 350), module, ModalBell::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xRight, 350), module, ModalBell::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelModalBell = createModel<WiggleRoom::ModalBell, WiggleRoom::ModalBellWidget>("ModalBell");
