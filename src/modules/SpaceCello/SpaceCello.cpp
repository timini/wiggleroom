/******************************************************************************
 * SPACE CELLO - Cathedral Yaybahar
 * Full coupled physical model with sympathetic strings and reverb
 * String -> Spring -> Tube -> Sympathetic Strings -> Reverb
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#include "ImagePanel.hpp"
#define FAUST_MODULE_NAME SpaceCello
#include "space_cello.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * SpaceCello - Cathedral Yaybahar
 *
 * A massive coupled resonator system inspired by the acoustic Yaybahar.
 *
 * Signal chain:
 *   1. String (Karplus-Strong) - provides pitch
 *   2. Spring (Allpass dispersion) - laser/sci-fi effect
 *   3. Tube (Waveguide) - sympathetic body resonance
 *   4. Sympathetic Strings - octave + fifth shimmer
 *   5. Reverb - cathedral space
 */
struct SpaceCello : FaustModule<VCVRackDSP> {
    enum ParamId {
        PITCH_PARAM,
        BODY_PARAM,
        TUBE_PARAM,
        SPRING_PARAM,
        SYMPATH_PARAM,
        REVERB_PARAM,
        DECAY_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        VOCT_INPUT,
        GATE_INPUT,
        TUBE_CV_INPUT,
        BODY_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    SpaceCello() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Configure parameters
        configParam(PITCH_PARAM, -2.0f, 8.0f, 0.0f, "String Pitch", " V");
        configParam(BODY_PARAM, 0.0f, 1.0f, 0.5f, "Body Size", "%", 0.f, 100.f);
        configParam(TUBE_PARAM, 0.25f, 4.0f, 1.0f, "Tube Ratio", "x");
        configParam(SPRING_PARAM, 0.0f, 1.0f, 0.5f, "Spring", "%", 0.f, 100.f);
        configParam(SYMPATH_PARAM, 0.0f, 1.0f, 0.5f, "Sympathetic", "%", 0.f, 100.f);
        configParam(REVERB_PARAM, 0.0f, 1.0f, 0.3f, "Reverb", "%", 0.f, 100.f);
        configParam(DECAY_PARAM, 0.5f, 0.999f, 0.97f, "Decay", "%", 0.f, 100.f);

        // Configure inputs
        configInput(VOCT_INPUT, "V/Oct");
        configInput(GATE_INPUT, "Gate");
        configInput(TUBE_CV_INPUT, "Tube CV");
        configInput(BODY_CV_INPUT, "Body CV");

        // Configure outputs
        configOutput(LEFT_OUTPUT, "Left");
        configOutput(RIGHT_OUTPUT, "Right");

        // Faust params (alphabetical): body=0, decay=1, gate=2, reverb=3, spring=4, sympath=5, tube=6, volts=7
        mapParam(BODY_PARAM, 0);
        mapParam(DECAY_PARAM, 1);
        // gate=2 handled manually
        mapParam(REVERB_PARAM, 3);
        mapParam(SPRING_PARAM, 4);
        mapParam(SYMPATH_PARAM, 5);
        mapParam(TUBE_PARAM, 6);
        mapParam(PITCH_PARAM, 7);
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Get pitch with V/Oct input
        float volts = params[PITCH_PARAM].getValue();
        if (inputs[VOCT_INPUT].isConnected()) {
            volts += inputs[VOCT_INPUT].getVoltage();
        }
        volts = clamp(volts, -2.f, 8.f);

        // Get body with CV modulation
        float body = params[BODY_PARAM].getValue();
        if (inputs[BODY_CV_INPUT].isConnected()) {
            body += inputs[BODY_CV_INPUT].getVoltage() * 0.1f;
        }
        body = clamp(body, 0.f, 1.f);

        // Get tube ratio with CV modulation
        float tube = params[TUBE_PARAM].getValue();
        if (inputs[TUBE_CV_INPUT].isConnected()) {
            tube += inputs[TUBE_CV_INPUT].getVoltage() * 0.2f;
        }
        tube = clamp(tube, 0.1f, 5.0f);

        // Get other parameters
        float spring = params[SPRING_PARAM].getValue();
        float sympath = params[SYMPATH_PARAM].getValue();
        float reverb = params[REVERB_PARAM].getValue();
        float decay = params[DECAY_PARAM].getValue();

        // Get gate (trigger)
        float gate = inputs[GATE_INPUT].isConnected() ?
                     (inputs[GATE_INPUT].getVoltage() > 1.0f ? 1.0f : 0.0f) : 0.0f;

        // Update Faust parameters (alphabetical order)
        faustDsp.setParamValue(0, body);     // body
        faustDsp.setParamValue(1, decay);    // decay
        faustDsp.setParamValue(2, gate);     // gate
        faustDsp.setParamValue(3, reverb);   // reverb
        faustDsp.setParamValue(4, spring);   // spring
        faustDsp.setParamValue(5, sympath);  // sympath
        faustDsp.setParamValue(6, tube);     // tube
        faustDsp.setParamValue(7, volts);    // volts

        // Process audio (no input, stereo output)
        float* nullInputs[1] = { nullptr };
        float outputL = 0.0f, outputR = 0.0f;
        float* outputPtrs[2] = { &outputL, &outputR };

        faustDsp.compute(1, nullInputs, outputPtrs);

        // Output - scale appropriately
        outputs[LEFT_OUTPUT].setVoltage(outputL * 5.0f);
        outputs[RIGHT_OUTPUT].setVoltage(outputR * 5.0f);
    }
};

struct SpaceCelloWidget : ModuleWidget {
    SpaceCelloWidget(SpaceCello* module) {
        setModule(module);
        box.size = Vec(4 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);
        addChild(new WiggleRoom::ImagePanel(
            asset::plugin(pluginInstance, "res/SpaceCello.png"), box.size));

        // Screws (4HP)
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        float xCenter = box.size.x / 2.0f;
        float xLeft = xCenter - 15;
        float xRight = xCenter + 15;

        // Pitch knob (big) at top center
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(xCenter, 50), module, SpaceCello::PITCH_PARAM));

        // Body and Tube side by side
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 95), module, SpaceCello::BODY_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 95), module, SpaceCello::TUBE_PARAM));

        // Spring and Sympath side by side
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xLeft, 140), module, SpaceCello::SPRING_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xRight, 140), module, SpaceCello::SYMPATH_PARAM));

        // Reverb and Decay side by side
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xLeft, 180), module, SpaceCello::REVERB_PARAM));
        addParam(createParamCentered<RoundSmallBlackKnob>(
            Vec(xRight, 180), module, SpaceCello::DECAY_PARAM));

        // CV Inputs (2x2 grid)
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 225), module, SpaceCello::VOCT_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 225), module, SpaceCello::GATE_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 265), module, SpaceCello::BODY_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 265), module, SpaceCello::TUBE_CV_INPUT));

        // Stereo Outputs
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xLeft, 320), module, SpaceCello::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xRight, 320), module, SpaceCello::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelSpaceCello = createModel<WiggleRoom::SpaceCello, WiggleRoom::SpaceCelloWidget>("SpaceCello");
