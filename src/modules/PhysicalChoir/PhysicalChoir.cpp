/******************************************************************************
 * PHYSICAL CHOIR
 * Hybrid Source-Filter Vocal Synthesis
 * Combines physical glottis modeling with formant filtering
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#include "ImagePanel.hpp"
#define FAUST_MODULE_NAME PhysicalChoir
#include "physical_choir.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * PhysicalChoir - Hybrid Physical Vocal Synthesis
 *
 * A voice synthesizer that combines physical modeling of the glottis
 * (vocal cords) with formant filtering (vocal tract) for organic,
 * expressive vocal sounds.
 *
 * Inputs:
 *   - V/Oct: Pitch control (0V = C4)
 *   - Gate: Triggers the voice
 *
 * Parameters:
 *   - Vowel: Morphs A-E-I-O-U vowel shapes
 *   - Tension: Vocal cord tightness (falsetto to chest voice)
 *   - Breath: Air turbulence/whisper amount
 *   - Throat: Voice size (child to giant)
 *   - Portamento: Pitch glide time
 *   - Reverb: Choir ambience
 */
struct PhysicalChoir : FaustModule<VCVRackDSP> {
    enum ParamId {
        VOWEL_PARAM,
        TENSION_PARAM,
        BREATH_PARAM,
        THROAT_PARAM,
        PORTAMENTO_PARAM,
        REVERB_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        VOCT_INPUT,
        GATE_INPUT,
        VOWEL_CV_INPUT,
        TENSION_CV_INPUT,
        BREATH_CV_INPUT,
        THROAT_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    PhysicalChoir() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Configure parameters
        configParam(VOWEL_PARAM, 0.0f, 4.0f, 0.0f, "Vowel", "", 0.f, 1.f);
        configParam(TENSION_PARAM, 0.1f, 0.99f, 0.6f, "Tension", "%", 0.f, 100.f);
        configParam(BREATH_PARAM, 0.0f, 1.0f, 0.05f, "Breath", "%", 0.f, 100.f);
        configParam(THROAT_PARAM, 0.5f, 2.0f, 1.0f, "Throat Length", "x");
        configParam(PORTAMENTO_PARAM, 0.0f, 0.2f, 0.02f, "Portamento", " s");
        configParam(REVERB_PARAM, 0.0f, 1.0f, 0.2f, "Reverb", "%", 0.f, 100.f);

        // Configure inputs
        configInput(VOCT_INPUT, "V/Oct");
        configInput(GATE_INPUT, "Gate");
        configInput(VOWEL_CV_INPUT, "Vowel CV");
        configInput(TENSION_CV_INPUT, "Tension CV");
        configInput(BREATH_CV_INPUT, "Breath CV");
        configInput(THROAT_CV_INPUT, "Throat CV");

        // Configure outputs
        configOutput(LEFT_OUTPUT, "Left");
        configOutput(RIGHT_OUTPUT, "Right");

        // Faust params (alphabetical): breath=0, gate=1, portamento=2, reverb=3, tension=4, throat=5, volts=6, vowel=7
        mapParam(BREATH_PARAM, 0);
        mapParam(PORTAMENTO_PARAM, 2);
        mapParam(REVERB_PARAM, 3);
        mapParam(TENSION_PARAM, 4);
        mapParam(THROAT_PARAM, 5);
        mapParam(VOWEL_PARAM, 7);
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Get V/Oct and Gate inputs
        float voct = inputs[VOCT_INPUT].getVoltage();
        float gate = inputs[GATE_INPUT].getVoltage();

        // Get vowel with CV modulation
        float vowel = params[VOWEL_PARAM].getValue();
        if (inputs[VOWEL_CV_INPUT].isConnected()) {
            vowel += inputs[VOWEL_CV_INPUT].getVoltage() * 0.4f;  // ±10V = ±4 vowels
        }
        vowel = clamp(vowel, 0.f, 4.f);

        // Get tension with CV modulation
        float tension = params[TENSION_PARAM].getValue();
        if (inputs[TENSION_CV_INPUT].isConnected()) {
            tension += inputs[TENSION_CV_INPUT].getVoltage() * 0.089f;  // ±10V = ±0.89
        }
        tension = clamp(tension, 0.1f, 0.99f);

        // Get breath with CV modulation
        float breath = params[BREATH_PARAM].getValue();
        if (inputs[BREATH_CV_INPUT].isConnected()) {
            breath += inputs[BREATH_CV_INPUT].getVoltage() * 0.1f;  // ±10V = ±1.0
        }
        breath = clamp(breath, 0.f, 1.f);

        // Get throat with CV modulation
        float throat = params[THROAT_PARAM].getValue();
        if (inputs[THROAT_CV_INPUT].isConnected()) {
            throat += inputs[THROAT_CV_INPUT].getVoltage() * 0.15f;  // ±10V = ±1.5
        }
        throat = clamp(throat, 0.5f, 2.f);

        // Get portamento (no CV)
        float portamento = params[PORTAMENTO_PARAM].getValue();

        // Get reverb (no CV)
        float reverb = params[REVERB_PARAM].getValue();

        // Update Faust parameters (alphabetical order)
        faustDsp.setParamValue(0, breath);      // breath
        faustDsp.setParamValue(1, gate);        // gate
        faustDsp.setParamValue(2, portamento);  // portamento
        faustDsp.setParamValue(3, reverb);      // reverb
        faustDsp.setParamValue(4, tension);     // tension
        faustDsp.setParamValue(5, throat);      // throat
        faustDsp.setParamValue(6, voct);        // volts
        faustDsp.setParamValue(7, vowel);       // vowel

        // Process audio (no input, stereo output)
        float* nullInputs[1] = { nullptr };
        float outputL = 0.0f, outputR = 0.0f;
        float* outputPtrs[2] = { &outputL, &outputR };

        faustDsp.compute(1, nullInputs, outputPtrs);

        // Output at 5V peak
        outputs[LEFT_OUTPUT].setVoltage(outputL * 5.0f);
        outputs[RIGHT_OUTPUT].setVoltage(outputR * 5.0f);
    }
};

struct PhysicalChoirWidget : ModuleWidget {
    PhysicalChoirWidget(PhysicalChoir* module) {
        setModule(module);
        box.size = Vec(8 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);
        addChild(new WiggleRoom::ImagePanel(
            asset::plugin(pluginInstance, "res/PhysicalChoir.png"), box.size));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        float xCenter = box.size.x / 2.0f;
        float xLeft = xCenter - 25;
        float xRight = xCenter + 25;

        // VOICE section - Vowel and Tension at top
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(xCenter, 55), module, PhysicalChoir::VOWEL_PARAM));

        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 105), module, PhysicalChoir::TENSION_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 105), module, PhysicalChoir::BREATH_PARAM));

        // BODY section - Throat and Portamento
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 155), module, PhysicalChoir::THROAT_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 155), module, PhysicalChoir::PORTAMENTO_PARAM));

        // Reverb
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xCenter, 200), module, PhysicalChoir::REVERB_PARAM));

        // CV Inputs (4 inputs in a row)
        float cvY = 245;
        float cvSpacing = 28;
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter - cvSpacing * 1.5f, cvY), module, PhysicalChoir::VOWEL_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter - cvSpacing * 0.5f, cvY), module, PhysicalChoir::TENSION_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter + cvSpacing * 0.5f, cvY), module, PhysicalChoir::BREATH_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter + cvSpacing * 1.5f, cvY), module, PhysicalChoir::THROAT_CV_INPUT));

        // V/Oct and Gate inputs
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 290), module, PhysicalChoir::VOCT_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 290), module, PhysicalChoir::GATE_INPUT));

        // Stereo Outputs
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xLeft, 335), module, PhysicalChoir::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xRight, 335), module, PhysicalChoir::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelPhysicalChoir = createModel<WiggleRoom::PhysicalChoir, WiggleRoom::PhysicalChoirWidget>("PhysicalChoir");
