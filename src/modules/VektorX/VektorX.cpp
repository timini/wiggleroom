/******************************************************************************
 * VektorX
 * Complex drone synthesizer with cluster oscillators and diffuse reverb
 * 4-oscillator cluster scanning synthesis with organic movement
 * Built with modular Faust DSP libraries
 * Inspired by Forge TME VHIKK X
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#include "ImagePanel.hpp"
#define FAUST_MODULE_NAME VektorX
#include "vektorx.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * VektorX - Complex Drone Synthesizer (inspired by Forge TME VHIKK X)
 *
 * Features:
 *   - Cluster Scanning synthesis (4 morphing oscillators with frequency spread)
 *   - Three algorithm modes: Virtual Analog, Cluster, Diatonic
 *   - Field filter with tilt control (LP/BP/HP morphing)
 *   - Diffuse reverb processor
 *   - Soft clipping saturation
 *
 * Inputs:
 *   - V/Oct: Pitch control (0V = C4)
 *   - Gate: Triggers envelope
 *   - CV inputs for various parameters
 *
 * Outputs:
 *   - Stereo audio (Left/Right)
 */
struct VektorX : FaustModule<VCVRackDSP> {
    enum ParamId {
        ALGORITHM_PARAM,
        MORPH_PARAM,
        SPREAD_PARAM,
        WIDTH_PARAM,
        WARP_PARAM,
        FIELD_PARAM,
        RESONANCE_PARAM,
        TILT_PARAM,
        DRIVE_PARAM,
        DECAY_PARAM,
        DELAY_MIX_PARAM,
        VCA_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        VOCT_INPUT,
        GATE_INPUT,
        MORPH_CV_INPUT,
        SPREAD_CV_INPUT,
        FIELD_CV_INPUT,
        VCA_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    VektorX() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Configure parameters
        configSwitch(ALGORITHM_PARAM, 0.f, 2.f, 0.f, "Algorithm",
            {"Virtual Analog", "Cluster", "Diatonic"});
        configParam(MORPH_PARAM, 0.0f, 1.0f, 0.5f, "Morph", "%", 0.f, 100.f);
        configParam(SPREAD_PARAM, 0.0f, 1.0f, 0.3f, "Spread", "%", 0.f, 100.f);
        configParam(WIDTH_PARAM, 0.0f, 1.0f, 0.5f, "Stereo Width", "%", 0.f, 100.f);
        configParam(WARP_PARAM, -1.0f, 1.0f, 0.0f, "Warp (FM/RM)");
        configParam(FIELD_PARAM, 20.f, 15000.f, 1000.f, "Field (Cutoff)", " Hz");
        configParam(RESONANCE_PARAM, 0.0f, 0.95f, 0.3f, "Resonance", "%", 0.f, 100.f);
        configParam(TILT_PARAM, -1.0f, 1.0f, 0.0f, "Tilt (LP/BP/HP)");
        configParam(DRIVE_PARAM, 1.0f, 3.0f, 1.0f, "Drive");
        configParam(DECAY_PARAM, 0.0f, 1.0f, 0.5f, "Decay", "%", 0.f, 100.f);
        configParam(DELAY_MIX_PARAM, 0.0f, 1.0f, 0.3f, "Delay Mix", "%", 0.f, 100.f);
        configParam(VCA_PARAM, 0.0f, 1.0f, 1.0f, "VCA Level", "%", 0.f, 100.f);

        // Configure inputs
        configInput(VOCT_INPUT, "V/Oct");
        configInput(GATE_INPUT, "Gate");
        configInput(MORPH_CV_INPUT, "Morph CV");
        configInput(SPREAD_CV_INPUT, "Spread CV");
        configInput(FIELD_CV_INPUT, "Field CV");
        configInput(VCA_CV_INPUT, "VCA CV");

        // Configure outputs
        configOutput(LEFT_OUTPUT, "Left");
        configOutput(RIGHT_OUTPUT, "Right");

        // Faust parameter mapping (alphabetical order from vektorx.dsp):
        // 0=algorithm, 1=decay, 2=delay_mix, 3=drive, 4=field,
        // 5=gate, 6=morph, 7=resonance, 8=spread, 9=tilt,
        // 10=vca, 11=volts, 12=warp, 13=width
        mapParam(ALGORITHM_PARAM, 0);   // algorithm
        mapParam(DECAY_PARAM, 1);       // decay
        mapParam(DELAY_MIX_PARAM, 2);   // delay_mix
        mapParam(DRIVE_PARAM, 3);       // drive
        mapParam(FIELD_PARAM, 4);       // field
        // gate (5) - handled manually
        mapParam(MORPH_PARAM, 6);       // morph
        mapParam(RESONANCE_PARAM, 7);   // resonance
        mapParam(SPREAD_PARAM, 8);      // spread
        mapParam(TILT_PARAM, 9);        // tilt
        mapParam(VCA_PARAM, 10);        // vca
        // volts (11) - handled manually
        mapParam(WARP_PARAM, 12);       // warp
        mapParam(WIDTH_PARAM, 13);      // width
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Update mapped parameters (from knobs)
        updateFaustParams();

        // Get V/Oct input
        float voct = inputs[VOCT_INPUT].getVoltage();
        faustDsp.setParamValue(11, voct);  // volts

        // Get Gate input
        float gate = inputs[GATE_INPUT].getVoltage();
        faustDsp.setParamValue(5, gate);   // gate

        // Apply CV modulation to morph
        if (inputs[MORPH_CV_INPUT].isConnected()) {
            float morph = params[MORPH_PARAM].getValue();
            morph += inputs[MORPH_CV_INPUT].getVoltage() * 0.1f;  // +10V = +1.0
            morph = clamp(morph, 0.f, 1.f);
            faustDsp.setParamValue(6, morph);
        }

        // Apply CV modulation to spread
        if (inputs[SPREAD_CV_INPUT].isConnected()) {
            float spread = params[SPREAD_PARAM].getValue();
            spread += inputs[SPREAD_CV_INPUT].getVoltage() * 0.1f;
            spread = clamp(spread, 0.f, 1.f);
            faustDsp.setParamValue(8, spread);
        }

        // Apply CV modulation to field (V/Oct style)
        if (inputs[FIELD_CV_INPUT].isConnected()) {
            float field = params[FIELD_PARAM].getValue();
            float cvVoltage = inputs[FIELD_CV_INPUT].getVoltage();
            field *= std::pow(2.f, cvVoltage);  // V/Oct
            field = clamp(field, 20.f, 20000.f);
            faustDsp.setParamValue(4, field);
        }

        // Apply CV modulation to VCA (cascades to other params)
        if (inputs[VCA_CV_INPUT].isConnected()) {
            float vcaCV = inputs[VCA_CV_INPUT].getVoltage() * 0.1f;  // +10V = +1.0

            // VCA level
            float vca = params[VCA_PARAM].getValue() + vcaCV;
            vca = clamp(vca, 0.f, 1.f);
            faustDsp.setParamValue(10, vca);

            // CV normalling: modulate other params slightly when VCA CV is connected
            float scaledCV = vcaCV * 0.3f;  // Reduced amount for subtle modulation

            // Morph modulation (if no dedicated CV)
            if (!inputs[MORPH_CV_INPUT].isConnected()) {
                float morph = params[MORPH_PARAM].getValue() + scaledCV;
                morph = clamp(morph, 0.f, 1.f);
                faustDsp.setParamValue(6, morph);
            }

            // Spread modulation (if no dedicated CV)
            if (!inputs[SPREAD_CV_INPUT].isConnected()) {
                float spread = params[SPREAD_PARAM].getValue() + scaledCV;
                spread = clamp(spread, 0.f, 1.f);
                faustDsp.setParamValue(8, spread);
            }

            // Field modulation (if no dedicated CV)
            if (!inputs[FIELD_CV_INPUT].isConnected()) {
                float field = params[FIELD_PARAM].getValue();
                field *= std::pow(2.f, scaledCV * 2.f);  // Subtle V/Oct modulation
                field = clamp(field, 20.f, 20000.f);
                faustDsp.setParamValue(4, field);
            }
        }

        // Process audio (no input, stereo output)
        float* nullInputs[1] = { nullptr };
        float outputL = 0.0f, outputR = 0.0f;
        float* outputPtrs[2] = { &outputL, &outputR };

        faustDsp.compute(1, nullInputs, outputPtrs);

        // Output at 5V peak
        outputs[LEFT_OUTPUT].setVoltage(outputL * 5.0f);
        outputs[RIGHT_OUTPUT].setVoltage(outputR * 5.0f);
    }
};

struct VektorXWidget : ModuleWidget {
    VektorXWidget(VektorX* module) {
        setModule(module);
        box.size = Vec(20 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);  // 20 HP

        // Use PNG panel with ImagePanel
        addChild(new ImagePanel(
            asset::plugin(pluginInstance, "res/VektorX.png"), box.size));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        // Layout constants
        float col1 = 30.f, col2 = 75.f, col3 = 120.f, col4 = 165.f, col5 = 210.f, col6 = 255.f;
        float row1 = 50.f, row2 = 95.f, row3 = 140.f, row4 = 185.f, row5 = 230.f, row6 = 280.f;

        // Row 1: Algorithm switch and Morph
        addParam(createParamCentered<CKSSThree>(
            Vec(col1, row1), module, VektorX::ALGORITHM_PARAM));
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(col3, row1), module, VektorX::MORPH_PARAM));

        // Row 2: Spread, Width, Warp
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(col1, row2), module, VektorX::SPREAD_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(col2, row2), module, VektorX::WIDTH_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(col3, row2), module, VektorX::WARP_PARAM));

        // Field section - Field, Resonance, Tilt
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(col4, row1), module, VektorX::FIELD_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(col5, row2), module, VektorX::RESONANCE_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(col6, row2), module, VektorX::TILT_PARAM));

        // Row 3: VCA and Drive
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(col1, row3), module, VektorX::VCA_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(col2, row3), module, VektorX::DRIVE_PARAM));

        // Row 3 right: Processor - Decay, Delay Mix
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(col4, row3), module, VektorX::DECAY_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(col5, row3), module, VektorX::DELAY_MIX_PARAM));

        // Row 4: CV Inputs
        addInput(createInputCentered<PJ301MPort>(
            Vec(col1, row4), module, VektorX::MORPH_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(col2, row4), module, VektorX::SPREAD_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(col4, row4), module, VektorX::FIELD_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(col5, row4), module, VektorX::VCA_CV_INPUT));

        // Row 5: Main inputs and outputs
        addInput(createInputCentered<PJ301MPort>(
            Vec(col1, row5), module, VektorX::VOCT_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(col2, row5), module, VektorX::GATE_INPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(col5, row5), module, VektorX::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(col6, row5), module, VektorX::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelVektorX = createModel<WiggleRoom::VektorX, WiggleRoom::VektorXWidget>("VektorX");
