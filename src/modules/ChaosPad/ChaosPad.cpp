/******************************************************************************
 * CHAOSPAD
 * Kaoss Pad-style multi-FX for drum mangling
 * 8 stereo effects with X/Y/Z control, clock sync, latch, attenuverters
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#include "ImagePanel.hpp"
#define FAUST_MODULE_NAME ChaosPad
#include "chaos_pad.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

struct ChaosPad : FaustModule<VCVRackDSP> {
    enum ParamId {
        X_PARAM,
        Y_PARAM,
        Z_PARAM,
        X_ATTEN_PARAM,
        Y_ATTEN_PARAM,
        Z_ATTEN_PARAM,
        FX_SELECT_PARAM,
        MIX_PARAM,
        CLOCK_DIV_PARAM,
        LATCH_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        LEFT_INPUT,
        RIGHT_INPUT,
        X_CV_INPUT,
        Y_CV_INPUT,
        Z_CV_INPUT,
        GATE_INPUT,
        FX_SELECT_CV_INPUT,
        CLOCK_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LATCH_LIGHT,
        LIGHTS_LEN
    };

    // Clock detection
    dsp::SchmittTrigger clockTrigger;
    float timeSinceClock = 0.f;
    float clockPeriod = 0.5f;  // Default 120 BPM
    bool clockDetected = false;

    // Latch toggle
    dsp::BooleanTrigger latchTrigger;
    bool latchState = false;

    // Gate envelope (slew-limited)
    float gateEnv = 0.f;

    // Clock div/mult values (discrete musical ratios)
    static constexpr int NUM_DIVMULT = 17;
    static constexpr float DIVMULT_VALUES[NUM_DIVMULT] = {
        1.f/16, 1.f/12, 1.f/8, 1.f/6, 1.f/4, 1.f/3, 1.f/2, 2.f/3,
        1.f,
        3.f/2, 2.f, 3.f, 4.f, 6.f, 8.f, 12.f, 16.f
    };

    // FX names for display
    static constexpr const char* FX_NAMES[8] = {
        "LPF", "Bitcrush", "Delay", "Grain",
        "Pitch", "Reverb", "Flanger", "RingMod"
    };

    ChaosPad() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // X/Y/Z knobs (0-1)
        configParam(X_PARAM, 0.f, 1.f, 0.5f, "X");
        configParam(Y_PARAM, 0.f, 1.f, 0.5f, "Y");
        configParam(Z_PARAM, 0.f, 1.f, 0.5f, "Z");

        // Attenuverters (-1 to +1)
        configParam(X_ATTEN_PARAM, -1.f, 1.f, 0.f, "X CV Attenuverter", "%", 0.f, 100.f);
        configParam(Y_ATTEN_PARAM, -1.f, 1.f, 0.f, "Y CV Attenuverter", "%", 0.f, 100.f);
        configParam(Z_ATTEN_PARAM, -1.f, 1.f, 0.f, "Z CV Attenuverter", "%", 0.f, 100.f);

        // FX Select (snapped 0-7)
        auto* fxParam = configSwitch(FX_SELECT_PARAM, 0.f, 7.f, 0.f, "FX Select",
            {"LPF", "Bitcrush", "Delay", "Grain", "Pitch", "Reverb", "Flanger", "Ring Mod"});
        (void)fxParam;

        // Mix (dry/wet)
        configParam(MIX_PARAM, 0.f, 1.f, 0.5f, "Mix", "%", 0.f, 100.f);

        // Clock Div/Mult (snapped to musical ratios)
        configSwitch(CLOCK_DIV_PARAM, 0.f, (float)(NUM_DIVMULT - 1), 8.f, "Clock Div/Mult",
            {"/16", "/12", "/8", "/6", "/4", "/3", "/2", "x2/3",
             "x1",
             "x3/2", "x2", "x3", "x4", "x6", "x8", "x12", "x16"});

        // Latch button
        configButton(LATCH_PARAM, "Latch");

        // Inputs
        configInput(LEFT_INPUT, "Audio L");
        configInput(RIGHT_INPUT, "Audio R");
        configInput(X_CV_INPUT, "X CV");
        configInput(Y_CV_INPUT, "Y CV");
        configInput(Z_CV_INPUT, "Z CV");
        configInput(GATE_INPUT, "Gate");
        configInput(FX_SELECT_CV_INPUT, "FX Select CV");
        configInput(CLOCK_INPUT, "Clock");

        // Outputs
        configOutput(LEFT_OUTPUT, "Audio L");
        configOutput(RIGHT_OUTPUT, "Audio R");

        // No mapParam/mapCVInput - we handle everything manually in process()
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        float dt = args.sampleTime;

        // --- Clock Detection ---
        timeSinceClock += dt;
        if (inputs[CLOCK_INPUT].isConnected()) {
            if (clockTrigger.process(inputs[CLOCK_INPUT].getVoltage(), 0.1f, 1.f)) {
                clockPeriod = timeSinceClock;
                clockDetected = true;
                timeSinceClock = 0.f;
            }
            // Timeout: if no clock for 4 seconds, mark as unsynced
            if (timeSinceClock > 4.f) {
                clockDetected = false;
            }
        } else {
            clockDetected = false;
        }

        // --- Latch Toggle ---
        if (latchTrigger.process(params[LATCH_PARAM].getValue() > 0.f)) {
            latchState = !latchState;
        }
        lights[LATCH_LIGHT].setBrightness(latchState ? 1.f : 0.f);

        // --- Gate Envelope (slew-limited) ---
        float gateTarget = (latchState || inputs[GATE_INPUT].getVoltage() > 0.9f) ? 1.f : 0.f;
        // 10ms attack, 50ms release
        float attackCoeff = 1.f - std::exp(-dt / 0.010f);
        float releaseCoeff = 1.f - std::exp(-dt / 0.050f);
        gateEnv += (gateTarget - gateEnv) * (gateTarget > gateEnv ? attackCoeff : releaseCoeff);

        // --- X/Y/Z with Attenuverters ---
        float xVal = clamp(params[X_PARAM].getValue()
            + inputs[X_CV_INPUT].getVoltage() * 0.1f * params[X_ATTEN_PARAM].getValue(), 0.f, 1.f);
        float yVal = clamp(params[Y_PARAM].getValue()
            + inputs[Y_CV_INPUT].getVoltage() * 0.1f * params[Y_ATTEN_PARAM].getValue(), 0.f, 1.f);
        float zVal = clamp(params[Z_PARAM].getValue()
            + inputs[Z_CV_INPUT].getVoltage() * 0.1f * params[Z_ATTEN_PARAM].getValue(), 0.f, 1.f);

        // --- FX Select (with CV) ---
        float fxSel = params[FX_SELECT_PARAM].getValue();
        if (inputs[FX_SELECT_CV_INPUT].isConnected()) {
            fxSel += inputs[FX_SELECT_CV_INPUT].getVoltage() * 0.8f;  // ±10V = ±8 slots
        }
        fxSel = clamp(std::round(fxSel), 0.f, 7.f);

        // --- Clock Div/Mult ---
        int divMultIdx = clamp((int)std::round(params[CLOCK_DIV_PARAM].getValue()), 0, NUM_DIVMULT - 1);
        float divMultRatio = DIVMULT_VALUES[divMultIdx];

        // --- Set Faust parameters (alphabetical order) ---
        // 0=clock_period, 1=clock_synced, 2=div_mult, 3=fx_select,
        // 4=gate_env, 5=mix, 6=x, 7=y, 8=z
        faustDsp.setParamValue(0, clockPeriod);
        faustDsp.setParamValue(1, clockDetected ? 1.f : 0.f);
        faustDsp.setParamValue(2, divMultRatio);
        faustDsp.setParamValue(3, fxSel);
        faustDsp.setParamValue(4, gateEnv);
        faustDsp.setParamValue(5, params[MIX_PARAM].getValue());
        faustDsp.setParamValue(6, xVal);
        faustDsp.setParamValue(7, yVal);
        faustDsp.setParamValue(8, zVal);

        // --- Audio I/O ---
        // Get stereo input (mono-normalized: R copies L if disconnected)
        float inL = inputs[LEFT_INPUT].getVoltage() * 0.2f;  // Scale 10V to ~2.0
        float inR = inputs[RIGHT_INPUT].isConnected()
            ? inputs[RIGHT_INPUT].getVoltage() * 0.2f
            : inL;

        float* inputPtrs[2] = { &inL, &inR };
        float outL = 0.f, outR = 0.f;
        float* outputPtrs[2] = { &outL, &outR };

        faustDsp.compute(1, inputPtrs, outputPtrs);

        // Output at 5V peak
        outputs[LEFT_OUTPUT].setVoltage(outL * 5.f);
        outputs[RIGHT_OUTPUT].setVoltage(outR * 5.f);
    }

    json_t* dataToJson() override {
        json_t* root = json_object();
        json_object_set_new(root, "latchState", json_boolean(latchState));
        return root;
    }

    void dataFromJson(json_t* root) override {
        json_t* latch = json_object_get(root, "latchState");
        if (latch) latchState = json_boolean_value(latch);
    }
};

constexpr float ChaosPad::DIVMULT_VALUES[];

struct ChaosPadWidget : ModuleWidget {
    ChaosPadWidget(ChaosPad* module) {
        setModule(module);

        // Set module size (16HP)
        box.size = Vec(16 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);

        // Add PNG faceplate background
        addChild(new WiggleRoom::ImagePanel(
            asset::plugin(pluginInstance, "res/ChaosPad.png"), box.size));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        // Layout constants
        float col1 = 30.f;
        float col2 = box.size.x / 4.f;
        float col3 = box.size.x / 2.f;
        float col4 = box.size.x * 3.f / 4.f;
        float col5 = box.size.x - 30.f;

        // --- Row 1: X, Y, Z big knobs ---
        float row1 = 60.f;
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(col2, row1), module, ChaosPad::X_PARAM));
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(col3, row1), module, ChaosPad::Y_PARAM));
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(col4, row1), module, ChaosPad::Z_PARAM));

        // --- Row 2: X/Y/Z Attenuverters ---
        float row2 = 105.f;
        addParam(createParamCentered<Trimpot>(
            Vec(col2, row2), module, ChaosPad::X_ATTEN_PARAM));
        addParam(createParamCentered<Trimpot>(
            Vec(col3, row2), module, ChaosPad::Y_ATTEN_PARAM));
        addParam(createParamCentered<Trimpot>(
            Vec(col4, row2), module, ChaosPad::Z_ATTEN_PARAM));

        // --- Row 3: FX Select, Mix, Clock Div ---
        float row3 = 150.f;
        addParam(createParamCentered<RoundBlackSnapKnob>(
            Vec(col2, row3), module, ChaosPad::FX_SELECT_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(col3, row3), module, ChaosPad::MIX_PARAM));
        addParam(createParamCentered<RoundBlackSnapKnob>(
            Vec(col4, row3), module, ChaosPad::CLOCK_DIV_PARAM));

        // --- Row 4: Latch button + light ---
        float row4 = 195.f;
        addParam(createParamCentered<VCVButton>(
            Vec(col3, row4), module, ChaosPad::LATCH_PARAM));
        addChild(createLightCentered<MediumLight<GreenLight>>(
            Vec(col3 + 18.f, row4), module, ChaosPad::LATCH_LIGHT));

        // --- Row 5: CV inputs ---
        float row5 = 240.f;
        addInput(createInputCentered<PJ301MPort>(
            Vec(col1, row5), module, ChaosPad::X_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(col2, row5), module, ChaosPad::Y_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(col3, row5), module, ChaosPad::Z_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(col4, row5), module, ChaosPad::FX_SELECT_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(col5, row5), module, ChaosPad::CLOCK_INPUT));

        // --- Row 6: Gate input ---
        float row6 = 285.f;
        addInput(createInputCentered<PJ301MPort>(
            Vec(col3, row6), module, ChaosPad::GATE_INPUT));

        // --- Row 7: Audio I/O ---
        float row7 = 330.f;
        addInput(createInputCentered<PJ301MPort>(
            Vec(col1, row7), module, ChaosPad::LEFT_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(col2, row7), module, ChaosPad::RIGHT_INPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(col4, row7), module, ChaosPad::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(col5, row7), module, ChaosPad::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelChaosPad = createModel<WiggleRoom::ChaosPad, WiggleRoom::ChaosPadWidget>("ChaosPad");
