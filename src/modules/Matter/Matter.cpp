/******************************************************************************
 * MATTER
 * Physical model: struck solid inside resonant tube
 * Mallet (Exciter) -> Block (Modal Resonator) -> Tube (Waveguide)
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#include "ImagePanel.hpp"
#define FAUST_MODULE_NAME Matter
#include "matter.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * Matter - Physical Model of a Struck Solid in a Tube
 *
 * Simulates hitting a block/bar/plate with a mallet, with the sound
 * resonating through a tube chamber. Morphs from strings to bells.
 *
 * Inputs:
 *   - V/Oct: Pitch control (0V = C4)
 *   - Gate: Trigger input (strikes when > 0.5V)
 *   - Structure CV: Morph material (string -> bell)
 *   - Position CV: Strike location (center -> edge)
 *   - Hardness CV: Mallet type (felt -> wood)
 *
 * Parameters:
 *   - Hardness: Mallet softness (0 = felt, 1 = wood)
 *   - Structure: Material type (0 = harmonic, 1 = inharmonic)
 *   - Position: Strike position (0 = center, 1 = edge)
 *   - Decay: Block ring time
 *   - Tube: Tube length ratio (1.0 = unison with block)
 *   - Tube Mix: Dry/wet tube blend
 */
struct Matter : FaustModule<VCVRackDSP> {
    enum ParamId {
        HARDNESS_PARAM,
        STRUCTURE_PARAM,
        POSITION_PARAM,
        DECAY_PARAM,
        TUBE_PARAM,
        TUBE_MIX_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        VOCT_INPUT,
        GATE_INPUT,
        STRUCTURE_CV_INPUT,
        POSITION_CV_INPUT,
        HARDNESS_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    Matter() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Configure parameters
        configParam(HARDNESS_PARAM, 0.01f, 1.0f, 0.5f, "Mallet Hardness");
        configParam(STRUCTURE_PARAM, 0.0f, 1.0f, 0.5f, "Material");
        configParam(POSITION_PARAM, 0.0f, 1.0f, 0.2f, "Strike Position");
        configParam(DECAY_PARAM, 0.1f, 2.0f, 0.8f, "Block Decay");
        configParam(TUBE_PARAM, 0.5f, 2.0f, 1.0f, "Tube Size");
        configParam(TUBE_MIX_PARAM, 0.0f, 1.0f, 0.5f, "Tube Mix");

        // Configure inputs
        configInput(VOCT_INPUT, "V/Oct");
        configInput(GATE_INPUT, "Gate");
        configInput(STRUCTURE_CV_INPUT, "Structure CV");
        configInput(POSITION_CV_INPUT, "Position CV");
        configInput(HARDNESS_CV_INPUT, "Hardness CV");

        // Configure outputs
        configOutput(LEFT_OUTPUT, "Left");
        configOutput(RIGHT_OUTPUT, "Right");

        // Map VCV parameters to Faust DSP parameters
        // Faust params (alphabetical): decay=0, gate=1, hardness=2, position=3, structure=4, tube=5, tube_mix=6, volts=7
        mapParam(DECAY_PARAM, 0);
        mapParam(HARDNESS_PARAM, 2);
        mapParam(POSITION_PARAM, 3);
        mapParam(STRUCTURE_PARAM, 4);
        mapParam(TUBE_PARAM, 5);
        mapParam(TUBE_MIX_PARAM, 6);

        // Map CV inputs with linear modulation (0.1 scale = ±10V maps to ±1.0)
        mapCVInput(HARDNESS_CV_INPUT, 2, false, 0.1f);
        mapCVInput(POSITION_CV_INPUT, 3, false, 0.1f);
        mapCVInput(STRUCTURE_CV_INPUT, 4, false, 0.1f);
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Update all mapped parameters (knobs + CV modulation)
        updateFaustParams();

        // Set gate and V/Oct directly (not mapped)
        // Faust params (alphabetical): gate=1, volts=7
        faustDsp.setParamValue(1, inputs[GATE_INPUT].getVoltage());
        faustDsp.setParamValue(7, inputs[VOCT_INPUT].getVoltage());

        // Process audio (no input, stereo output)
        float* nullInputs[1] = { nullptr };
        float outputL = 0.0f, outputR = 0.0f;
        float* outputPtrs[2] = { &outputL, &outputR };

        faustDsp.compute(1, nullInputs, outputPtrs);

        // Output at 5V peak (VCV standard)
        outputs[LEFT_OUTPUT].setVoltage(outputL * 5.0f);
        outputs[RIGHT_OUTPUT].setVoltage(outputR * 5.0f);
    }
};

struct MatterWidget : ModuleWidget {
    MatterWidget(Matter* module) {
        setModule(module);
        box.size = Vec(8 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);
        addChild(new WiggleRoom::ImagePanel(
            asset::plugin(pluginInstance, "res/Matter.png"), box.size));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        float xCenter = box.size.x / 2.0f;
        float xLeft = box.size.x * 0.25f;
        float xRight = box.size.x * 0.75f;

        // Main knobs - The Object
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 60), module, Matter::STRUCTURE_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 60), module, Matter::POSITION_PARAM));

        // Mallet and Decay
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 110), module, Matter::HARDNESS_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 110), module, Matter::DECAY_PARAM));

        // Tube controls
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xLeft, 165), module, Matter::TUBE_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xRight, 165), module, Matter::TUBE_MIX_PARAM));

        // CV inputs
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft - 10, 215), module, Matter::STRUCTURE_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter, 215), module, Matter::POSITION_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight + 10, 215), module, Matter::HARDNESS_CV_INPUT));

        // Pitch and Gate inputs
        addInput(createInputCentered<PJ301MPort>(
            Vec(xLeft, 270), module, Matter::VOCT_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xRight, 270), module, Matter::GATE_INPUT));

        // Outputs
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xLeft, 320), module, Matter::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xRight, 320), module, Matter::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelMatter = createModel<WiggleRoom::Matter, WiggleRoom::MatterWidget>("Matter");
