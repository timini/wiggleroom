/******************************************************************************
 * BIG REVERB
 * Lush stereo reverb using the Zita Rev1 algorithm
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#define FAUST_MODULE_NAME BigReverb
#include "big_reverb.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * BigReverb - Lush Stereo Reverb (Zita Rev1)
 *
 * A high-quality 8-line FDN reverb with independent bass/treble decay.
 * Creates smooth, expensive-sounding halls without metallic ringing.
 *
 * Parameters:
 *   - Pre-Delay: Gap before reverb starts (0-200ms)
 *   - Bass Decay: Low frequency decay time (0.1-60s)
 *   - Treble Decay: High frequency decay time (0.1-20s)
 *   - Crossover: Bass/treble split frequency (50-6000Hz)
 *   - Damping: HF rolloff for warmth (100-15000Hz)
 *   - Mix: Dry/Wet balance
 */
struct BigReverb : FaustModule<VCVRackDSP> {
    enum ParamId {
        PREDELAY_PARAM,
        DECAY_LOW_PARAM,
        DECAY_HIGH_PARAM,
        XOVER_PARAM,
        DAMPING_PARAM,
        MIX_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        LEFT_INPUT,
        RIGHT_INPUT,
        MIX_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    BigReverb() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Configure parameters
        configParam(PREDELAY_PARAM, 0.f, 200.f, 20.f, "Pre-Delay", " ms");
        configParam(DECAY_LOW_PARAM, 0.1f, 60.f, 3.f, "Bass Decay", " s");
        configParam(DECAY_HIGH_PARAM, 0.1f, 20.f, 2.f, "Treble Decay", " s");
        configParam(XOVER_PARAM, 50.f, 6000.f, 200.f, "Crossover", " Hz");
        configParam(DAMPING_PARAM, 100.f, 15000.f, 5000.f, "Damping", " Hz");
        configParam(MIX_PARAM, 0.f, 1.f, 0.5f, "Mix", "%", 0.f, 100.f);

        // Configure inputs
        configInput(LEFT_INPUT, "Left");
        configInput(RIGHT_INPUT, "Right");
        configInput(MIX_CV_INPUT, "Mix CV");

        // Configure outputs
        configOutput(LEFT_OUTPUT, "Left");
        configOutput(RIGHT_OUTPUT, "Right");

        // Map VCV parameters to Faust DSP parameters (alphabetical order)
        // Faust params: damping=0, decay_high=1, decay_low=2, mix=3, predelay=4, xover=5
        mapParam(DAMPING_PARAM, 0);
        mapParam(DECAY_HIGH_PARAM, 1);
        mapParam(DECAY_LOW_PARAM, 2);
        mapParam(MIX_PARAM, 3);
        mapParam(PREDELAY_PARAM, 4);
        mapParam(XOVER_PARAM, 5);
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Get mix value with CV modulation
        float mix = params[MIX_PARAM].getValue();
        if (inputs[MIX_CV_INPUT].isConnected()) {
            mix += inputs[MIX_CV_INPUT].getVoltage() * 0.1f;  // 10V = full sweep
        }
        mix = clamp(mix, 0.f, 1.f);

        // Update Faust parameters (alphabetical order)
        faustDsp.setParamValue(0, params[DAMPING_PARAM].getValue());     // damping
        faustDsp.setParamValue(1, params[DECAY_HIGH_PARAM].getValue());  // decay_high
        faustDsp.setParamValue(2, params[DECAY_LOW_PARAM].getValue());   // decay_low
        faustDsp.setParamValue(3, mix);                                   // mix (with CV)
        faustDsp.setParamValue(4, params[PREDELAY_PARAM].getValue());    // predelay
        faustDsp.setParamValue(5, params[XOVER_PARAM].getValue());       // xover

        // Get stereo input (normalize to Faust range)
        float inputL = inputs[LEFT_INPUT].getVoltage() * 0.2f;  // 5V -> 1.0
        float inputR = inputs[RIGHT_INPUT].isConnected()
            ? inputs[RIGHT_INPUT].getVoltage() * 0.2f
            : inputL;  // Mono to stereo if only left connected

        float* inputPtrs[2] = { &inputL, &inputR };
        float outputL = 0.0f, outputR = 0.0f;
        float* outputPtrs[2] = { &outputL, &outputR };

        // Process audio
        faustDsp.compute(1, inputPtrs, outputPtrs);

        // Output (back to VCV voltage range)
        outputs[LEFT_OUTPUT].setVoltage(outputL * 5.0f);
        outputs[RIGHT_OUTPUT].setVoltage(outputR * 5.0f);
    }
};

struct BigReverbWidget : ModuleWidget {
    BigReverbWidget(BigReverb* module) {
        setModule(module);
        setPanel(createPanel(asset::plugin(pluginInstance, "res/BigReverb.svg")));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        float xCenter = box.size.x / 2.0f;

        // Big Decay knobs at top
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(xCenter - 22, 55), module, BigReverb::DECAY_LOW_PARAM));
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(xCenter + 22, 55), module, BigReverb::DECAY_HIGH_PARAM));

        // Pre-delay and Damping
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xCenter - 22, 110), module, BigReverb::PREDELAY_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xCenter + 22, 110), module, BigReverb::DAMPING_PARAM));

        // Crossover and Mix
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xCenter - 22, 160), module, BigReverb::XOVER_PARAM));
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(xCenter + 22, 160), module, BigReverb::MIX_PARAM));

        // CV Input
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter, 210), module, BigReverb::MIX_CV_INPUT));

        // Audio Inputs
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter - 22, 260), module, BigReverb::LEFT_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter + 22, 260), module, BigReverb::RIGHT_INPUT));

        // Audio Outputs
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xCenter - 22, 310), module, BigReverb::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xCenter + 22, 310), module, BigReverb::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelBigReverb = createModel<WiggleRoom::BigReverb, WiggleRoom::BigReverbWidget>("BigReverb");
