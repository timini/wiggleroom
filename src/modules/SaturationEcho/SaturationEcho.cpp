/******************************************************************************
 * SATURATION ECHO
 * Vintage tape delay with saturation and wobble in the feedback loop
 * Built with Faust DSP
 ******************************************************************************/

#include "rack.hpp"
#include "FaustModule.hpp"
#define FAUST_MODULE_NAME SaturationEcho
#include "saturation_echo.hpp"  // Generated by Faust

using namespace rack;

extern Plugin* pluginInstance;

namespace WiggleRoom {

/**
 * SaturationEcho - Vintage Tape Delay Emulation
 *
 * A tape delay with filter and saturation in the feedback loop.
 * Each repeat gets darker and grittier, creating the organic "Dub" sound.
 *
 * Features:
 *   - Self-oscillation capability (feedback > 100%)
 *   - Wow/Flutter simulation (tape motor wobble)
 *   - Cubic interpolation for smooth pitch shifting
 *   - High-quality tape saturation
 */
struct SaturationEcho : FaustModule<VCVRackDSP> {
    enum ParamId {
        TIME_PARAM,
        FEEDBACK_PARAM,
        TONE_PARAM,
        DRIVE_PARAM,
        WOBBLE_PARAM,
        MIX_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        LEFT_INPUT,
        RIGHT_INPUT,
        TIME_CV_INPUT,
        FEEDBACK_CV_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        LEFT_OUTPUT,
        RIGHT_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    SaturationEcho() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        // Configure parameters with real-world units
        configParam(TIME_PARAM, 1.f, 1000.f, 350.f, "Delay Time", " ms");
        configParam(FEEDBACK_PARAM, 0.f, 1.1f, 0.5f, "Feedback", "%", 0.f, 100.f);
        configParam(TONE_PARAM, 100.f, 15000.f, 4000.f, "Tone", " Hz");
        configParam(DRIVE_PARAM, 0.f, 1.f, 0.2f, "Drive", "%", 0.f, 100.f);
        configParam(WOBBLE_PARAM, 0.f, 10.f, 0.f, "Wobble", " ms");
        configParam(MIX_PARAM, 0.f, 1.f, 0.5f, "Mix", "%", 0.f, 100.f);

        // Configure inputs
        configInput(LEFT_INPUT, "Left");
        configInput(RIGHT_INPUT, "Right");
        configInput(TIME_CV_INPUT, "Time CV");
        configInput(FEEDBACK_CV_INPUT, "Feedback CV");

        // Configure outputs
        configOutput(LEFT_OUTPUT, "Left");
        configOutput(RIGHT_OUTPUT, "Right");

        // Faust params (alphabetical order):
        // 0=drive, 1=feedback, 2=mix, 3=time, 4=tone, 5=wobble
        mapParam(DRIVE_PARAM, 0);
        mapParam(FEEDBACK_PARAM, 1);
        mapParam(MIX_PARAM, 2);
        mapParam(TIME_PARAM, 3);
        mapParam(TONE_PARAM, 4);
        mapParam(WOBBLE_PARAM, 5);
    }

    void process(const ProcessArgs& args) override {
        // Initialize DSP on first run
        if (!initialized) {
            faustDsp.init(static_cast<int>(args.sampleRate));
            initialized = true;
        }

        // Get base parameter values
        float time = params[TIME_PARAM].getValue();
        float feedback = params[FEEDBACK_PARAM].getValue();

        // Apply CV modulation
        if (inputs[TIME_CV_INPUT].isConnected()) {
            time += inputs[TIME_CV_INPUT].getVoltage() * 100.f;  // 1V = +100ms
        }
        if (inputs[FEEDBACK_CV_INPUT].isConnected()) {
            feedback += inputs[FEEDBACK_CV_INPUT].getVoltage() * 0.1f;  // 1V = +10%
        }

        // Clamp values to safe ranges
        time = clamp(time, 1.f, 2000.f);
        feedback = clamp(feedback, 0.f, 1.2f);

        // Update Faust parameters
        faustDsp.setParamValue(0, params[DRIVE_PARAM].getValue());   // drive
        faustDsp.setParamValue(1, feedback);                          // feedback (with CV)
        faustDsp.setParamValue(2, params[MIX_PARAM].getValue());      // mix
        faustDsp.setParamValue(3, time);                              // time (with CV)
        faustDsp.setParamValue(4, params[TONE_PARAM].getValue());     // tone
        faustDsp.setParamValue(5, params[WOBBLE_PARAM].getValue());   // wobble

        // Get stereo input (normalize to Faust range)
        float inputL = inputs[LEFT_INPUT].getVoltage() * 0.2f;  // 5V -> 1.0
        float inputR = inputs[RIGHT_INPUT].isConnected()
            ? inputs[RIGHT_INPUT].getVoltage() * 0.2f
            : inputL;  // Mono to stereo if only left connected

        float* inputPtrs[2] = { &inputL, &inputR };
        float outputL = 0.0f, outputR = 0.0f;
        float* outputPtrs[2] = { &outputL, &outputR };

        // Process audio
        faustDsp.compute(1, inputPtrs, outputPtrs);

        // Output (back to VCV voltage range)
        outputs[LEFT_OUTPUT].setVoltage(outputL * 5.0f);
        outputs[RIGHT_OUTPUT].setVoltage(outputR * 5.0f);
    }
};

struct SaturationEchoWidget : ModuleWidget {
    SaturationEchoWidget(SaturationEcho* module) {
        setModule(module);
        setPanel(createPanel(asset::plugin(pluginInstance, "res/SaturationEcho.svg")));

        // Screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        float xCenter = box.size.x / 2.0f;

        // Main knobs - vertical layout
        addParam(createParamCentered<RoundBigBlackKnob>(
            Vec(xCenter, 55), module, SaturationEcho::TIME_PARAM));

        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xCenter - 18, 100), module, SaturationEcho::FEEDBACK_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xCenter + 18, 100), module, SaturationEcho::TONE_PARAM));

        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xCenter - 18, 145), module, SaturationEcho::DRIVE_PARAM));
        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xCenter + 18, 145), module, SaturationEcho::WOBBLE_PARAM));

        addParam(createParamCentered<RoundBlackKnob>(
            Vec(xCenter, 190), module, SaturationEcho::MIX_PARAM));

        // CV Inputs
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter - 18, 230), module, SaturationEcho::TIME_CV_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter + 18, 230), module, SaturationEcho::FEEDBACK_CV_INPUT));

        // Audio Inputs
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter - 18, 280), module, SaturationEcho::LEFT_INPUT));
        addInput(createInputCentered<PJ301MPort>(
            Vec(xCenter + 18, 280), module, SaturationEcho::RIGHT_INPUT));

        // Audio Outputs
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xCenter - 18, 330), module, SaturationEcho::LEFT_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(
            Vec(xCenter + 18, 330), module, SaturationEcho::RIGHT_OUTPUT));
    }
};

} // namespace WiggleRoom

Model* modelSaturationEcho = createModel<WiggleRoom::SaturationEcho, WiggleRoom::SaturationEchoWidget>("SaturationEcho");
